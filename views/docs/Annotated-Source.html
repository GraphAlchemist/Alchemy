<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>doc</title> <style>/*github.com style (c) Vasily Polovnyov <vast@whiteants.net>*/
      pre code {
        display: block; padding: 0.5em;
        color: #333;
        background: #f8f8ff
      }
      pre .comment,
      pre .template_comment,
      pre .diff .header,
      pre .javadoc {
        color: #998;
        font-style: italic
      }
      pre .keyword,
      pre .css .rule .keyword,
      pre .winutils,
      pre .javascript .title,
      pre .nginx .title,
      pre .subst,
      pre .request,
      pre .status {
        color: #333;
        font-weight: bold
      }
      pre .number,
      pre .hexcolor,
      pre .ruby .constant {
        color: #099;
      }
      pre .string,
      pre .tag .value,
      pre .phpdoc,
      pre .tex .formula {
        color: #d14
      }
      pre .title,
      pre .id {
        color: #900;
        font-weight: bold
      }
      pre .javascript .title,
      pre .lisp .title,
      pre .clojure .title,
      pre .subst {
        font-weight: normal
      }
      pre .class .title,
      pre .haskell .type,
      pre .vhdl .literal,
      pre .tex .command {
        color: #458;
        font-weight: bold
      }
      pre .tag,
      pre .tag .title,
      pre .rules .property,
      pre .django .tag .keyword {
        color: #000080;
        font-weight: normal
      }
      pre .attribute,
      pre .variable,
      pre .lisp .body {
        color: #008080
      }
      pre .regexp {
        color: #009926
      }
      pre .class {
        color: #458;
        font-weight: bold
      }
      pre .symbol,
      pre .ruby .symbol .string,
      pre .lisp .keyword,
      pre .tex .special,
      pre .prompt {
        color: #990073
      }
      pre .built_in,
      pre .lisp .title,
      pre .clojure .built_in {
        color: #0086b3
      }
      pre .preprocessor,
      pre .pi,
      pre .doctype,
      pre .shebang,
      pre .cdata {
        color: #999;
        font-weight: bold
      }
      pre .deletion {
        background: #fdd
      }
      pre .addition {
        background: #dfd
      }
      pre .diff .change {
        background: #0086b3
      }
      pre .chunk {
        color: #aaa
      }</style>  <body> <h2 id="anotated-source">Anotated Source</h2> <pre><code>&quot;&quot;&quot;
Alchemy.js is a graph drawing application for the web.
Copyright (C) 2014  GraphAlchemist, Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
lets
&quot;&quot;&quot;

class Alchemy
    constructor: (userConf=null) -&gt;
        @a = @

        @version  = &quot;#VERSION#&quot;
        @get      = new @get @
        @remove   = new @remove @
        @create   = new @create @
        @drawing  =
            DrawEdge : DrawEdge   @
            DrawEdges: DrawEdges  @
            DrawNode : DrawNode   @
            DrawNodes: DrawNodes  @
            EdgeUtils: @EdgeUtils @
            NodeUtils: @NodeUtils @

        @controlDash = @controlDash @
        @stats = @stats @

        @layout     = Layout
        @clustering = Clustering

        @models =
            Node: @Node @
            Edge: @Edge @

        @utils        = warnings: new warnings @
        @filters      = @filters @
        @exports      = @exports @
        @visControls  = {}
        @styles       = {}
        @editor       = {}
        @log          = {}

        @state =
            &quot;interactions&quot;: &quot;default&quot;
            &quot;layout&quot;: &quot;default&quot;

        @startGraph     = @startGraph @
        @generateLayout = @generateLayout @
        @svgStyles      = @svgStyles @
        @interactions   = @interactions @
        @search         = @search @

        # alchemy._nodes stores a node object as the value with the unique
        # id specified in the GraphJSON.
        @_nodes = {}

        # alchemy._edges stores an array of edges under every unique id.
        # the edge model is a key value pair where the &quot;key&quot; is either
        # 1) an id provided in the GraphJSON data, or 2) an id generated by
        # Alchemy taking the format of &quot;#{source}-#{target}&quot;.
        # The value is an array of edge &#39;packets&#39;, where the length of the array
        # is typically 1.
        @_edges = {}

        # Bind legacy API methods to earlier location
        # These will be deprecated on release-1.0
        @getNodes = @get.getNodes
        @getEdges = @get.getEdges
        @allNodes = @get.allNodes
        @allEdges = @get.allEdges

        @begin userConf if userConf

    begin: (userConf) -&gt;
        # overide configuration with user inputs
        @setConf userConf
        switch typeof @conf.dataSource
            when &#39;string&#39; then d3.json @a.conf.dataSource, @a.startGraph
            when &#39;object&#39; then @a.startGraph @a.conf.dataSource

        Alchemy::instances.push @

        @

    setConf: (userConf) -&gt;
        # apply base themes
        if userConf.theme?
            userConf = _.merge _.cloneDeep(defaults), @a.themes[&quot;#{userConf.theme}&quot;]

        for key, val of userConf
            switch key
                when &quot;clusterColors&quot;   then userConf[&quot;clusterColours&quot;]   = val
                when &quot;backgroundColor&quot; then userConf[&quot;backgroundColour&quot;] = val
                when &quot;nodeColor&quot;       then userConf[nodeColour]         = val

        @a.conf = _.merge _.cloneDeep(defaults), userConf

    # All alchemy instances in order of creation.
    instances: []

    getInst: (element)-&gt;
        #Edge or Node
        if element.a?
            element.a

        #_d3 packet
        else if element.self?
            element.self.a

        #SVG element
        else
            Alchemy::instances[d3.select(element).attr(&quot;alchInst&quot;)]


root = exports ? this
root.Alchemy = Alchemy

#Backwards compatible alchemy.begin() for single instances
root.alchemy = begin: (config)-&gt; root.alchemy = new Alchemy(config)

# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

class Alchemy::create
    constructor: (instance)-&gt;
        @a = instance
    nodes: (nodeMap, nodeMaps...) -&gt;
        a = this.a
        registerNode = (node) -&gt;
            # check if the node already exists
            if not a._nodes[node.id]
                aNode = new a.models.Node(node)
                a._nodes[node.id] = aNode
                [aNode]
            else
                # if the node already exists, suggest that the user uses a 
                # different method for creating/updating the node
                console.warn(&quot;&quot;&quot;
                            A node with the id #{node.id} already exists.
                            Consider using the @a.get.nodes() method to 
                            retrieve the node and then using the Node methods.
                            &quot;&quot;&quot;)

        nodeMaps = _.union nodeMaps, nodeMap
        # create the results set
        results = []
        for n in nodeMaps
            # check if the node already exists
            registerNode n
        results
    edges: (edgeMap, edgeMaps...) -&gt;
        a = this.a
        registerEdge = (edge) -&gt;
            # data provided a unique id and that edge does not yet exist
            if edge.id and not a._edges[edge.id]
                aEdge = new a.models.Edge(edge)
                a._edges[edge.id] = [aEdge]
                [aEdge]
            # data provided a unique id and that edge already exists
            else if edge.id and a._edges[edge.id]
                console.warn &quot;&quot;&quot;
                    An edge with that id #{someEdgeMap.id} already exists.
                    Consider using the @a.get.edge() method to 
                    retrieve the edge and then using the Edge methods.
                    Note: id&#39;s are not required for edges.  Alchemy will create
                    an unlimited number of edges for the same source and target node.
                    Simply omit &#39;id&#39; when creating the edge.
                    &quot;&quot;&quot;
            # data did not provide a unique id and so @a uses source-target
            else
                edgeArray = a._edges[&quot;#{edge.source}-#{edge.target}&quot;]
                if edgeArray
                    # edges already exist with this source target, append a new edge object
                    aEdge = new a.models.Edge(edge, edgeArray.length)
                    edgeArray.push aEdge
                    [aEdge]
                else
                    # edge array does not exist - create the array and give the edge
                    # an id of &#39;source-target-0&#39; for the first position in the array
                    aEdge = new a.models.Edge(edge, 0)
                    a._edges[&quot;#{edge.source}-#{edge.target}&quot;] = [aEdge]
                    [aEdge]

        if edgeMaps.length isnt 0
            console.warn &quot;Make sure this function supports multiple arguments&quot;
        else
            registerEdge edgeMap

# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.


# make js array method called ._state
# @a.set.  nest set inside of get

Alchemy::get = (instance)-&gt;
    a: instance
    _el: []
    _elType: null
    _makeChain: (inp)-&gt;
        returnedGet = @
        returnedGet.__proto__ = [].__proto__
        returnedGet.pop() while returnedGet.length
        _.each inp, (e)-&gt; returnedGet.push(e)
        returnedGet

    # returns one or more nodes as an array
    nodes: (id, ids...) -&gt;
                if id?
                    allIDs = _.map arguments, (arg) -&gt; String(arg)
                    a = @.a
                    nodeList = do (a) -&gt;
                        # All passed ids with artificially enforced type safety
                        _.filter a._nodes, (val, key)-&gt;
                            val if _.contains allIDs, key
                @_elType = &quot;node&quot;
                @_el = nodeList
                @_makeChain nodeList

    # returns one or more edges as an array
    edges: (id, ids...) -&gt;
        if id?
            allIDs = _.map arguments, (arg) -&gt; String(arg)
            a = @.a
            edgeList = do (a) -&gt;
                # All passed ids with artificially enforced type safety
                _.flatten _.filter a._edges, (val, key)-&gt;
                    val if _.contains allIDs, key
        @_elType = &quot;edge&quot;
        @_el = edgeList
        @_makeChain edgeList

    all: -&gt;
        a = @a
        elType = @_elType
        @_el = do (elType)-&gt;
            switch elType
                when &quot;node&quot; then return _.values a._nodes
                when &quot;edge&quot; then return _.flatten _.map a._edges, (e)-&gt; e
        @_makeChain @_el

    elState: (state) -&gt;
        elList = _.filter @_el, (e)-&gt; e._state is state
        @_el = elList
        @_makeChain elList

    state: (key) -&gt; if @a.state.key? then @a.state.key

    type: (type) -&gt;
        elList = _.filter @_el, (e) -&gt; e._nodeType is type or e._edgeType is type
        @_el = elList
        @_makeChain elList

    activeNodes: () -&gt;
        _.filter @a._nodes, (node) -&gt; node if node._state is &quot;active&quot;

    activeEdges: -&gt;
        _.filter @a.get.allEdges(), (edge) -&gt; edge if edge._state is &quot;active&quot;

    state: (key) -&gt; if @a.state.key? then @a.state.key

    clusters: -&gt;
        clusterMap = @a.layout._clustering.clusterMap
        nodesByCluster = {}
        _.each clusterMap, (key, value) -&gt;
            nodesByCluster[value] = _.select @a.get.allNodes(), (node) -&gt;
                node.getProperties()[@a.conf.clusterKey] is value
        nodesByCluster

    clusterColours: -&gt;
        clusterMap = @a.layout._clustering.clusterMap
        clusterColoursObject = {}
        _.each clusterMap, (key, value) -&gt;
           clusterColoursObject[value] = @a.conf.clusterColours[key % @a.conf.clusterColours.length]
        clusterColoursObject

    ###### ALL METHODS BELOW THIS POINT WILL BE DEPRECATED UPON 1.0 ######
    allEdges: -&gt;
        _.flatten _.map(@a._edges, (edgeArray) -&gt; e for e in edgeArray)

    allNodes: (type) -&gt;
        if type?
            _.filter @a._nodes, (n) -&gt; n if n._nodeType is type
        else
            _.map @a._nodes, (n) -&gt; n

    getNodes: (id, ids...)-&gt;
        a = @a
        ids.push(id)
        _.map ids, (id)-&gt; a._nodes[id]

    getEdges: (id=null, target=null)-&gt;
        a = @a
        if id? and target?
            edge_id = &quot;#{id}-#{target}&quot;
            @a._edges[edge_id]
        else if id? and not target?
            @a._nodes[id]._adjacentEdges
# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

class Alchemy::remove
    constructor: (instance)-&gt;
        @a = instance

    nodes: (nodeMap) -&gt;
        _.each nodeMap, (n) -&gt;
            if n._nodeType?
                n.remove()
    edges: (edgeMap) -&gt;
        _.each edgeMap, (e) -&gt;
            if e._edgeType?
                e.remove()

# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

Alchemy::set =
    state: (key, value) -&gt; alchemy.state.key = value

# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

class Clustering
    constructor: (instance)-&gt;
        @a = instance
        nodes = @a._nodes
        conf = @a.conf
        clustering = @

        @clusterKey = conf.clusterKey
        @identifyClusters @a

        _charge = -500
        _linkStrength = (edge) -&gt;
            sourceCluster = nodes[edge.source.id]._properties[@clusterKey]
            targetCluster = nodes[edge.target.id]._properties[@clusterKey]
            if sourceCluster is targetCluster
                0.15
            else
                0
        _friction = () -&gt;
            0.7
        _linkDistancefn = (edge) -&gt;
            nodes = edge.self.a._nodes
            if nodes[edge.source.id]._properties.root or nodes[edge.target.id]._properties.root
                300
            else if nodes[edge.source.id]._properties[@clusterKey] is nodes[edge.target.id]._properties[@clusterKey]
                10
            else
                600
        _gravity = (k) -&gt; 8 * k

        @layout =
            charge: _charge
            linkStrength: (edge) -&gt; _linkStrength(edge)
            friction: () -&gt; _friction()
            linkDistancefn: (edge) -&gt; _linkDistancefn(edge)
            gravity: (k) -&gt; _gravity(k)

    identifyClusters: (a)-&gt;
        nodes = a.get.allNodes()
        clusters = _.uniq _.map(_.values(nodes), (node)-&gt; node.getProperties()[a.conf.clusterKey])
        @clusterMap = _.zipObject clusters, [0..clusters.length]

    getClusterColour: (clusterValue) -&gt;
        # Modulo reuses colors if not enough are supplied
        index = @clusterMap[clusterValue] % @a.conf.clusterColours.length
        @a.conf.clusterColours[index]

    edgeGradient: (edges) -&gt;
        defs = @a.vis.select &quot;#{@a.conf.divSelector} svg&quot;
        Q = {}
        nodes = @a._nodes
        for edge in _.map(edges, (edge) -&gt; edge._d3)
            # skip root
            continue if nodes[edge.source.id]._properties.root or nodes[edge.target.id]._properties.root
            # skip nodes from the same cluster
            continue if nodes[edge.source.id]._properties[@clusterKey] is nodes[edge.target.id]._properties[@clusterKey]
            if nodes[edge.target.id]._properties[@clusterKey] isnt nodes[edge.source.id]._properties[@clusterKey]
                # gradient `id`
                id = nodes[edge.source.id]._properties[@clusterKey] + &quot;-&quot; + nodes[edge.target.id]._properties[@clusterKey]
                if id of Q
                    continue
                else if id not of Q
                    startColour = @getClusterColour(nodes[edge.target.id]._properties[@clusterKey])
                    endColour = @getClusterColour(nodes[edge.source.id]._properties[@clusterKey])
                    Q[id] = {&#39;startColour&#39;: startColour,&#39;endColour&#39;: endColour}
        for ids of Q
            gradient_id = &quot;cluster-gradient-&quot; + ids
            gradient = defs.append(&quot;svg:linearGradient&quot;).attr(&quot;id&quot;, gradient_id)
            gradient.append(&quot;svg:stop&quot;).attr(&quot;offset&quot;, &quot;0%&quot;).attr &quot;stop-color&quot;, Q[ids][&#39;startColour&#39;]
            gradient.append(&quot;svg:stop&quot;).attr(&quot;offset&quot;, &quot;100%&quot;).attr &quot;stop-color&quot;, Q[ids][&#39;endColour&#39;]

Alchemy::clusterControls =
    init: ()-&gt;
        changeClusterHTML = &quot;&quot;&quot;
                            &lt;input class=&#39;form-control form-inline&#39; id=&#39;cluster-key&#39; placeholder=&quot;Cluster Key&quot;&gt;&lt;/input&gt;
                            &quot;&quot;&quot;
        @a.dash
               .select &quot;#clustering-container&quot;
               .append &quot;div&quot;
               .attr &quot;id&quot;, &quot;cluster-key-container&quot;
               .attr &#39;class&#39;, &#39;property form-inline form-group&#39;
               .html changeClusterHTML
               .style &quot;display&quot;, &quot;none&quot;

        @a.dash
               .select &quot;#cluster_control_header&quot;
               .on &quot;click&quot;, ()-&gt;
                    element = @a.dash.select &quot;#cluster-key-container&quot;
                    display = element.style &quot;display&quot;

            element.style &quot;display&quot;, (e)-&gt; if display is &quot;block&quot; then &quot;none&quot; else &quot;block&quot;

            if @a.dash.select(&quot;#cluster-key-container&quot;).style(&quot;display&quot;) is &quot;none&quot;
                @a.dash
                       .select &quot;#cluster-arrow&quot;
                       .attr &quot;class&quot;, &quot;fa fa-2x fa-caret-right&quot;
            else 
                @a.dash
                       .select &quot;#cluster-arrow&quot;
                       .attr &quot;class&quot;, &quot;fa fa-2x fa-caret-down&quot;

        @a.dash
            .select &quot;#cluster-key&quot;
            .on &quot;keydown&quot;, -&gt; 
                if d3.event.keyIdentifier is &quot;Enter&quot;
                    @a.conf.cluster = true
                    @a.conf.clusterKey = this.value
                    @a.generateLayout()

# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

Alchemy::controlDash = (instance) -&gt;
    a = instance

    init: () -&gt;
        if @dashIsShown()
            divSelector = a.conf.divSelector
            # add dashboard wrapper
            a.dash = d3.select &quot;#{divSelector}&quot;
                             .append &quot;div&quot;
                             .attr &quot;id&quot;, &quot;control-dash-wrapper&quot;
                             .attr &quot;class&quot;, &quot;col-md-4 initial&quot;

            # add the dash toggle button 
            a.dash
                   .append &quot;i&quot;
                   .attr &quot;id&quot;, &quot;dash-toggle&quot;
                   .attr &quot;class&quot;, &quot;fa fa-flask col-md-offset-12&quot;

            # add the control dash
            a.dash
                   .append &quot;div&quot;
                   .attr &quot;id&quot;, &quot;control-dash&quot;
                   .attr &quot;class&quot;, &quot;col-md-12&quot;

            a.dash.select &#39;#dash-toggle&#39;
                   .on &#39;click&#39;, a.interactions.toggleControlDash

            a.controlDash.zoomCtrl()
            a.controlDash.search()
            a.controlDash.filters()
            a.controlDash.stats()
            a.controlDash.clustering()
            a.controlDash.exports()

    search: -&gt;
        if a.conf.search
            a.dash
                   .select &quot;#control-dash&quot;
                   .append &quot;div&quot;
                   .attr &quot;id&quot;, &quot;search&quot;
                   .html &quot;&quot;&quot;
                        &lt;div class=&#39;input-group&#39;&gt;
                            &lt;input class=&#39;form-control&#39; placeholder=&#39;Search&#39;&gt;
                            &lt;i class=&#39;input-group-addon search-icon&#39;&gt;&lt;span class=&#39;fa fa-search fa-1x&#39;&gt;&lt;/span&gt;&lt;/i&gt;
                        &lt;/div&gt; 
                          &quot;&quot;&quot;
            a.search.init()

    zoomCtrl: -&gt;
        if a.conf.zoomControls 
            a.dash
                .select &quot;#control-dash-wrapper&quot;
                .append &quot;div&quot;
                .attr &quot;id&quot;, &quot;zoom-controls&quot;
                .attr &quot;class&quot;, &quot;col-md-offset-12&quot;
                .html &quot;&lt;button id=&#39;zoom-reset&#39;  class=&#39;btn btn-defualt btn-primary&#39;&gt;&lt;i class=&#39;fa fa-crosshairs fa-lg&#39;&gt;&lt;/i&gt;&lt;/button&gt;
                        &lt;button id=&#39;zoom-in&#39;  class=&#39;btn btn-defualt btn-primary&#39;&gt;&lt;i class=&#39;fa fa-plus&#39;&gt;&lt;/i&gt;&lt;/button&gt;
                        &lt;button id=&#39;zoom-out&#39; class=&#39;btn btn-default btn-primary&#39;&gt;&lt;i class=&#39;fa fa-minus&#39;&gt;&lt;/i&gt;&lt;/button&gt;&quot;

            a.dash
                   .select &#39;#zoom-in&#39;
                   .on &quot;click&quot;, -&gt; a.interactions.clickZoom &#39;in&#39;

            a.dash
                   .select &#39;#zoom-out&#39;
                   .on &quot;click&quot;, -&gt; a.interactions.clickZoom &#39;out&#39;

            a.dash
                   .select &#39;#zoom-reset&#39;
                   .on &quot;click&quot;, -&gt; a.interactions.clickZoom &#39;reset&#39;

    filters: -&gt;
        if a.conf.nodeFilters or a.conf.edgeFilters
            a.dash
                .select &quot;#control-dash&quot;
                .append &quot;div&quot;
                .attr &quot;id&quot;, &quot;filters&quot;
            a.filters.init()

    stats: -&gt;
        if a.conf.nodeStats or a.conf.edgeStats
            stats_html = &quot;&quot;&quot;
                    &lt;div id = &quot;stats-header&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#stats #all-stats&quot;&gt;
                    &lt;h3&gt;
                        Statistics
                    &lt;/h3&gt;
                    &lt;span class = &quot;fa fa-caret-right fa-2x&quot;&gt;&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div id=&quot;all-stats&quot; class=&quot;collapse&quot;&gt;
                        &lt;ul class = &quot;list-group&quot; id=&quot;node-stats&quot;&gt;&lt;/ul&gt;
                        &lt;ul class = &quot;list-group&quot; id=&quot;rel-stats&quot;&gt;&lt;/ul&gt;  
                    &lt;/div&gt;
                &quot;&quot;&quot;

            a.dash
                .select &quot;#control-dash&quot;
                .append &quot;div&quot;
                .attr &quot;id&quot;, &quot;stats&quot;
                .html stats_html
                .select &#39;#stats-header&#39;
                .on &#39;click&#39;, () -&gt;
                    if a.dash.select(&#39;#all-stats&#39;).classed &quot;in&quot;
                        a.dash
                               .select &quot;#stats-header&gt;span&quot;
                               .attr &quot;class&quot;, &quot;fa fa-2x fa-caret-right&quot;
                    else
                        a.dash
                               .select &quot;#stats-header&gt;span&quot;
                               .attr &quot;class&quot;, &quot;fa fa-2x fa-caret-down&quot;

            a.stats.init()

    exports: -&gt;
        if a.conf.exportSVG
            exports_html = &quot;&quot;&quot;
                    &lt;div id=&quot;exports-header&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#all-exports&quot; style=&quot;padding:10px;&quot;&gt;
                        &lt;h3&gt;
                            Exports
                        &lt;/h3&gt;
                        &lt;span class=&quot;fa fa-caret-right fa-2x&quot;&gt;&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div id=&quot;all-exports&quot; class=&quot;collapse&quot;&gt;&lt;/div&gt;
                    &quot;&quot;&quot;
            a.dash.select &quot;#control-dash&quot;
             .append &quot;div&quot;
             .attr &quot;id&quot;, &quot;exports&quot;
             .attr &quot;style&quot;, &quot;padding: 0.5em 1em; border-bottom: thin dashed #E89619; color: white;&quot;
             .html exports_html
             .select &quot;#exports-header&quot;

            a.exports.init()

    clustering: -&gt;
        if a.conf.clusterControl
            clusterControl_html = &quot;&quot;&quot;
                    &lt;div id=&quot;clustering-container&quot;&gt;
                        &lt;div id=&quot;cluster_control_header&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#clustering #cluster-options&quot;&gt;
                             &lt;h3&gt;Clustering&lt;/h3&gt;
                            &lt;span id=&quot;cluster-arrow&quot; class=&quot;fa fa-2x fa-caret-right&quot;&gt;&lt;/span&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &quot;&quot;&quot;
            a.dash
                .select &quot;#control-dash&quot;
                .append &quot;div&quot;
                .attr &quot;id&quot;, &quot;clustering&quot;
                .html clusterControl_html
                .select &#39;#cluster_control_header&#39;

            a.clusterControls.init()

    dashIsShown: -&gt;
        conf = a.conf

        conf.showEditor    || conf.captionToggle  || conf.toggleRootNodes ||
        conf.removeElement || conf.clusterControl || conf.nodeStats       ||
        conf.edgeStats     || conf.edgeFilters    || conf.nodeFilters     || 
        conf.edgesToggle   || conf.nodesToggle    || conf.search          ||
        conf.exportSVG
# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
Alchemy::filters = (instance)=&gt;
    a = instance
    init: () -&gt;
        a.filters.show()

        if a.conf.edgeFilters then a.filters.showEdgeFilters()
        if a.conf.nodeFilters then a.filters.showNodeFilters()
        #generate filter forms
        if a.conf.nodeTypes
            nodeKey = Object.keys a.conf.nodeTypes

            nodeTypes = &#39;&#39;
            for nodeType in a.conf.nodeTypes[nodeKey]
                # Create Filter list element
                caption = nodeType.replace &#39;_&#39;, &#39; &#39;
                nodeTypes += &quot;&lt;li class=&#39;list-group-item nodeType&#39; role=&#39;menuitem&#39; id=&#39;li-#{nodeType}&#39; name=#{nodeType}&gt;#{caption}&lt;/li&gt;&quot;
            a.dash.select &#39;#node-dropdown&#39;
                   .html nodeTypes

        if a.conf.edgeTypes
            if _.isPlainObject a.conf.edgeTypes
                types = _.values(a.conf.edgeTypes)[0]
            else
                types = a.conf.edgeTypes

            edgeTypes = &#39;&#39;
            for edgeType in types
                # Create Filter list element
                caption = edgeType.replace &#39;_&#39;, &#39; &#39;
                edgeTypes += &quot;&lt;li class=&#39;list-group-item edgeType&#39; role=&#39;menuitem&#39; id=&#39;li-#{edgeType}&#39; name=#{edgeType}&gt;#{caption}&lt;/li&gt;&quot;
            a.dash.select &#39;#rel-dropdown&#39;
                   .html edgeTypes

        if a.conf.captionsToggle then a.filters.captionsToggle()
        if a.conf.edgesToggle then a.filters.edgesToggle()
        if a.conf.nodesToggle then a.filters.nodesToggle()
        a.filters.update()

    show: -&gt;
        filter_html = &quot;&quot;&quot;
                    &lt;div id = &quot;filter-header&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#filters form&quot;&gt;
                        &lt;h3&gt;Filters&lt;/h3&gt;
                        &lt;span class = &quot;fa fa-2x fa-caret-right&quot;&gt;&lt;/span&gt;
                    &lt;/div&gt;
                        &lt;form class=&quot;form-inline collapse&quot;&gt;
                        &lt;/form&gt;
                      &quot;&quot;&quot;
        a.dash.select(&#39;#control-dash #filters&#39;).html filter_html
        a.dash.selectAll &#39;#filter-header&#39;
            .on &#39;click&#39;, () -&gt;
                if a.dash.select(&#39;#filters&gt;form&#39;).classed &quot;in&quot;
                    a.dash.select &quot;#filter-header&gt;span&quot;
                           .attr &quot;class&quot;, &quot;fa fa-2x fa-caret-right&quot;
                else
                    a.dash.select &quot;#filter-header&gt;span&quot;
                           .attr &quot;class&quot;, &quot;fa fa-2x fa-caret-down&quot;

        a.dash.select &#39;#filters form&#39;
               # .submit false

    #create relationship filters
    showEdgeFilters: () -&gt;
        rel_filter_html = &quot;&quot;&quot;
                        &lt;div id=&quot;filter-rel-header&quot; data-target = &quot;#rel-dropdown&quot; data-toggle=&quot;collapse&quot;&gt;
                            &lt;h4&gt;
                                Edge Types
                            &lt;/h4&gt;
                            &lt;span class=&quot;fa fa-lg fa-caret-right&quot;&gt;&lt;/span&gt;
                        &lt;/div&gt;
                        &lt;ul id=&quot;rel-dropdown&quot; class=&quot;collapse list-group&quot; role=&quot;menu&quot;&gt;
                        &lt;/ul&gt;
                           &quot;&quot;&quot;
        a.dash.select &#39;#filters form&#39;
               .append &quot;div&quot;
               .attr &quot;id&quot;, &quot;filter-relationships&quot;
               .html rel_filter_html
        a.dash.select &quot;#filter-rel-header&quot;
            .on &#39;click&#39;, () -&gt;
                if a.dash.select(&#39;#rel-dropdown&#39;).classed &quot;in&quot;
                    a.dash.select &quot;#filter-rel-header&gt;span&quot;
                           .attr &quot;class&quot;, &quot;fa fa-lg fa-caret-right&quot;
                else
                    a.dash.select &quot;#filter-rel-header&gt;span&quot;
                           .attr &quot;class&quot;, &quot;fa fa-lg fa-caret-down&quot;

    #create node filters
    showNodeFilters: () -&gt;
        node_filter_html = &quot;&quot;&quot;
                            &lt;div id=&quot;filter-node-header&quot; data-target = &quot;#node-dropdown&quot; data-toggle=&quot;collapse&quot;&gt;
                                &lt;h4&gt;
                                    Node Types
                                &lt;/h4&gt;
                                &lt;span class=&quot;fa fa-lg fa-caret-right&quot;&gt;&lt;/span&gt;
                            &lt;/div&gt;
                            &lt;ul id=&quot;node-dropdown&quot; class=&quot;collapse list-group&quot; role=&quot;menu&quot;&gt;
                            &lt;/ul&gt;
                           &quot;&quot;&quot;
        a.dash.select &#39;#filters form&#39;
               .append &quot;div&quot;
               .attr &quot;id&quot;, &quot;filter-nodes&quot;
               .html node_filter_html
        a.dash.select &quot;#filter-node-header&quot;
            .on &#39;click&#39;, () -&gt;
                if a.dash.select(&#39;#node-dropdown&#39;).classed &quot;in&quot;
                    a.dash.select &quot;#filter-node-header&gt;span&quot;
                           .attr &quot;class&quot;, &quot;fa fa-lg fa-caret-right&quot;
                else
                    a.dash.select &quot;#filter-node-header&gt;span&quot;
                           .attr &quot;class&quot;, &quot;fa fa-lg fa-caret-down&quot;

    #create captions toggle
    captionsToggle: () -&gt;
        a.dash.select &quot;#filters form&quot;
          .append &quot;li&quot;
          .attr {&quot;id&quot;:&quot;toggle-captions&quot;,&quot;class&quot;:&quot;list-group-item active-label toggle&quot;}
          .html &quot;Show Captions&quot;
          .on &quot;click&quot;, -&gt;
            isDisplayed = a.dash.select(&quot;g text&quot;).attr(&quot;style&quot;)

            if isDisplayed is &quot;display: block&quot; || null
                a.dash.selectAll &quot;g text&quot;
                       .attr &quot;style&quot;, &quot;display: none&quot;
            else
                a.dash.selectAll &quot;g text&quot;
                       .attr &quot;style&quot;, &quot;display: block&quot;

    #create edges toggle
    edgesToggle: () -&gt;
        a.dash.select &quot;#filters form&quot;
          .append &quot;li&quot;
          .attr {&quot;id&quot;:&quot;toggle-edges&quot;,&quot;class&quot;:&quot;list-group-item active-label toggle&quot;}
          .html &quot;Toggle Edges&quot;
          .on &quot;click&quot;, -&gt;
              if _.contains(_.pluck(_.flatten(_.values(a._edges)), &quot;_state&quot;), &quot;active&quot;)
                _.each _.values(a._edges), (edges)-&gt;
                    _.each edges, (e)-&gt; if e._state is &quot;active&quot; then e.toggleHidden()
              else
                _.each _.values(a._edges), (edges)-&gt;
                    _.each edges, (e)-&gt;
                        source = a._nodes[e._properties.source]
                        target = a._nodes[e._properties.target]
                        if source._state is &quot;active&quot; and target._state is &quot;active&quot;
                          e.toggleHidden()

    #create nodes toggle
    nodesToggle: () -&gt;
        a.dash.select &quot;#filters form&quot;
            .append &quot;li&quot;
            .attr {&quot;id&quot;:&quot;toggle-nodes&quot;,&quot;class&quot;:&quot;list-group-item active-label toggle&quot;}
            .html &quot;Toggle Nodes&quot;
            .on &quot;click&quot;, -&gt;
                nodes = _.values(a._nodes)
                if _.contains _.pluck(nodes, &quot;_state&quot;), &quot;active&quot;
                    _.each nodes, (n)-&gt;
                        if a.conf.toggleRootNodes and n._d3.root then return
                        if n._state is &quot;active&quot; then n.toggleHidden()
                else
                    _.each _.values(a._nodes), (n)-&gt;
                        if a.conf.toggleRootNodes and n._d3.root then return
                        n.toggleHidden()

    #update filters
    update: () -&gt;
        a.dash.selectAll &quot;.nodeType, .edgeType&quot;
            .on &quot;click&quot;, () -&gt;
                element = d3.select this
                tag = element.attr &quot;name&quot;
                a.vis.selectAll &quot;.#{tag}&quot;
                    .each (d)-&gt;
                        if a._nodes[d.id]?
                            node = a._nodes[d.id]
                            node.toggleHidden()
                        else
                            edge = a._edges[d.id][0]
                            source = a._nodes[edge._properties.source]
                            target = a._nodes[edge._properties.target]
                            if source._state is &quot;active&quot; and target._state is &quot;active&quot;
                                edge.toggleHidden()
                a.stats.nodeStats()

# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

Alchemy::interactions = (instance)-&gt;
    a = instance

    edgeClick: (d) -&gt;
        a = d.self.a

        d3.event.stopPropagation()
        edge = d.self
        if edge._state != &quot;hidden&quot;
            edge._state = do -&gt;
                return &quot;active&quot; if edge._state is &quot;selected&quot;
                &quot;selected&quot;
            edge.setStyles()
        if typeof a.conf.edgeClick? is &#39;function&#39;
            a.conf.edgeClick()

    edgeMouseOver: (d) -&gt;
        edge = d.self
        if edge._state != &quot;hidden&quot;
            if edge._state != &quot;selected&quot;
                edge._state = &quot;highlighted&quot;
            edge.setStyles()

    edgeMouseOut: (d) -&gt;
        edge = d.self
        if edge._state != &quot;hidden&quot;
            if edge._state != &quot;selected&quot;
                edge._state = &quot;active&quot;
            edge.setStyles()

    nodeMouseOver: (n) -&gt;
        node = n.self
        if node._state != &quot;hidden&quot;
            if node._state != &quot;selected&quot;
                node._state = &quot;highlighted&quot;
                node.setStyles()
            if typeof a.conf.nodeMouseOver is &#39;function&#39;
                a.conf.nodeMouseOver(node)
            else if typeof a.conf.nodeMouseOver is (&#39;number&#39; or &#39;string&#39;)
                # the user provided an integer or string to be used
                # as a data lookup key on the node in the graph json
                node.properties[a.conf.nodeMouseOver]

    nodeMouseOut: (n) -&gt;
        node = n.self
        a = node.a
        if node._state != &quot;hidden&quot;
            if node._state != &quot;selected&quot;
                node._state = &quot;active&quot;
                node.setStyles()
            if a.conf.nodeMouseOut? and typeof a.conf.nodeMouseOut is &#39;function&#39;
                a.conf.nodeMouseOut(n)

    nodeClick: (n) -&gt;
        # Don&#39;t consider drag a click
        return if d3.event.defaultPrevented

        d3.event.stopPropagation()
        node = n.self

        if node._state != &quot;hidden&quot;
            node._state = do -&gt;
                return &quot;active&quot; if node._state is &quot;selected&quot;
                &quot;selected&quot;
            node.setStyles()
        if typeof a.conf.nodeClick is &#39;function&#39;
            a.conf.nodeClick(n)

    zoom: (extent) -&gt;
                if not @_zoomBehavior?
                    @_zoomBehavior = d3.behavior.zoom()
                @_zoomBehavior.scaleExtent extent
                              .on &quot;zoom&quot;, (d) -&gt;
                                a = Alchemy::getInst this
                                a.vis.attr(&quot;transform&quot;, &quot;translate(#{ d3.event.translate }) 
                                                          scale(#{ d3.event.scale })&quot; )
    clickZoom:  (direction) -&gt;
                    [x, y, scale] = a.vis
                                      .attr &quot;transform&quot;
                                      .match /(-*\d+\.*\d*)/g
                                      .map (a) -&gt; parseFloat(a)

                    a.vis
                        .attr &quot;transform&quot;, -&gt;
                            if direction is &quot;in&quot;
                                scale += 0.2 if scale &lt; a.conf.scaleExtent[1]
                                return &quot;translate(#{x},#{y}) scale(#{ scale })&quot;
                            else if direction is &quot;out&quot;
                                scale -= 0.2 if scale &gt; a.conf.scaleExtent[0]
                                return &quot;translate(#{x},#{y}) scale(#{ scale })&quot;
                            else if direction is &quot;reset&quot;
                                return &quot;translate(0,0) scale(1)&quot;
                            else
                                console.log &#39;error&#39;
                    if not @._zoomBehavior?
                        @._zoomBehavior = d3.behavior.zoom()
                    @._zoomBehavior.scale(scale)
                                   .translate([x,y])

    toggleControlDash: () -&gt;
        #toggle off-canvas class on click
        offCanvas = a.dash.classed(&quot;off-canvas&quot;) or
                    a.dash.classed(&quot;initial&quot;)
        a.dash
               .classed {
                    &quot;off-canvas&quot;: !offCanvas,
                    &quot;initial&quot;   : false,
                    &quot;on-canvas&quot; : offCanvas
                }

    nodeDragStarted: (d, i) -&gt;
        d3.event.preventDefault
        d3.event.sourceEvent.stopPropagation()
        d3.select(@).classed &quot;dragging&quot;, true
        d.fixed = true

    nodeDragged: (d, i) -&gt;
        a = d.self.a

        d.x  += d3.event.dx
        d.y  += d3.event.dy
        d.px += d3.event.dx
        d.py += d3.event.dy

        node = d3.select @
        node.attr &quot;transform&quot;, &quot;translate(#{d.x}, #{d.y})&quot;
        edges = d.self._adjacentEdges
        _.each edges, (edge) -&gt;
            selection = a.vis.select &quot;#edge-#{edge.id}-#{edge._index}&quot;
            a._drawEdges.updateEdge selection.data()[0]

    nodeDragended: (d, i) -&gt;
        a = d.self.a
        d3.select(@).classed &quot;dragging&quot;: false
        if !a.conf.forceLocked  #a.configuration for forceLocked
            a.force.start() #restarts force on drag

    nodeDoubleClick: (d)-&gt; null

    deselectAll: () -&gt;
        a = Alchemy::getInst @

        # this function is also fired at the end of a drag, do nothing if this
        if d3.event?.defaultPrevented then return
        if a.conf.showEditor is true
            a.modifyElements.nodeEditorClear()

        _.each a._nodes, (n)-&gt;
            n._state = &quot;active&quot;
            n.setStyles()

        _.each a._edges, (edge)-&gt;
            _.each edge, (e)-&gt;
                e._state = &quot;active&quot;
                e.setStyles()

        # call user-specified deselect function if specified
        if a.conf.deselectAll and typeof(a.conf.deselectAll is &#39;function&#39;)
            a.conf.deselectAll()

# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

class Layout
    constructor: (instance)-&gt;
        @a = instance

        conf = @a.conf
        nodes = @a._nodes

        @k = Math.sqrt Math.log(_.size(@a._nodes)) / (conf.graphWidth() * conf.graphHeight())
        @_clustering = new @a.clustering @a
        @d3NodeInternals = _.map @a._nodes, (v,k)-&gt; v._d3

        if conf.cluster
            @_charge = () -&gt; @_clustering.layout.charge
            @_linkStrength = (edge) -&gt; @_clustering.layout.linkStrength(edge)
        else
            @_charge = () -&gt; -10 / @k
            @_linkStrength = (edge) -&gt;
                if nodes[edge.source.id].getProperties(&#39;root&#39;) or nodes[edge.target.id].getProperties(&#39;root&#39;)
                    1
                else
                    0.9

        if conf.cluster
            @_linkDistancefn = (edge) -&gt; @_clustering.layout.linkDistancefn(edge)
        else if conf.linkDistancefn is &#39;default&#39;
            @_linkDistancefn = (edge) -&gt;
                1 / (@k * 50)
        else if typeof conf.linkDistancefn is &#39;number&#39;
            @_linkDistancefn = (edge) -&gt; conf.linkDistancefn
        else if typeof conf.linkDistancefn is &#39;function&#39;
            @_linkDistancefn = (edge) -&gt; conf.linkDistancefn(edge)



    gravity: () =&gt;
        if @a.conf.cluster
            @_clustering.layout.gravity @k
        else
            50 * @k

    linkStrength: (edge) =&gt;
        @_linkStrength edge

    friction: () -&gt; 0.9

    collide: (node) -&gt;
        conf = @a.conf
        r = 2 * (node.radius + node[&#39;stroke-width&#39;]) + conf.nodeOverlap
        nx1 = node.x - r
        nx2 = node.x + r
        ny1 = node.y - r
        ny2 = node.y + r
        return (quad, x1, y1, x2, y2) -&gt;
            if quad.point and (quad.point isnt node)
                x = node.x - Math.abs quad.point.x
                y = node.y - quad.point.y
                l = Math.sqrt(x * x + y * y)
                r = r
                if l &lt; r
                    l = (l - r) / l * @a.conf.alpha
                    node.x -= x *= l
                    node.y -= y *= l
                    quad.point.x += x
                    quad.point.y += y
            x1 &gt; nx2 or
            x2 &lt; nx1 or
            y1 &gt; ny2 or
            y2 &lt; ny1

    tick: () =&gt;
        if @a.conf.collisionDetectionls
            q = d3.geom.quadtree @d3NodeInternals
            for node in @d3NodeInternals
                q.visit @collide(node)

        # @a.node
        @a.vis
            .selectAll &quot;g.node&quot;
            .attr &quot;transform&quot;, (d) -&gt; &quot;translate(#{d.x},#{d.y})&quot;

        edges = @a.vis.selectAll &quot;g.edge&quot;
        @drawEdge = @a.drawing.DrawEdge
        @drawEdge.styleText edges
        @drawEdge.styleLink edges

    positionRootNodes: () -&gt;
        conf = @a.conf
        container =
            width: conf.graphWidth()
            height: conf.graphHeight()

        rootNodes = _.filter @a.get.allNodes(), (node) -&gt; node.getProperties(&#39;root&#39;)
        # if there is one root node, position it in the center
        if rootNodes.length is 1
            n = rootNodes[0]
            [n._d3.x, n._d3.px] = [container.width / 2, container.width / 2]
            [n._d3.y, n._d3.py] = [container.height/ 2, container.height/ 2]
            # fix root nodes until force layout is complete
            n._d3.fixed = true
            return
        # position nodes towards center of graph
        else
            for n, i in rootNodes
                n._d3.x = container.width / Math.sqrt(rootNodes.length * (i+1))
                n._d3.y = container.height / 2
                n._d3.fixed = true

    chargeDistance: () -&gt;
        500

    linkDistancefn: (edge) -&gt;
        @_linkDistancefn edge

    charge: () -&gt;
        @_charge()

Alchemy::generateLayout = (instance)-&gt;
    a = instance
    (start=false)-&gt;
        conf = a.conf

        a.layout = new Layout a
        a.force = d3.layout.force()
            .size [conf.graphWidth(), conf.graphHeight()]
            .theta 1.0
            .gravity a.layout.gravity()
            .friction a.layout.friction()

            .nodes _.map(a._nodes, (node) -&gt; node._d3)
            .links _.flatten _.map(a._edges, (edgeArray) -&gt; e._d3 for e in edgeArray)
            .linkDistance (link) -&gt; a.layout.linkDistancefn link
            .linkStrength (link) -&gt; a.layout.linkStrength link

            .charge a.layout.charge()
            .chargeDistance a.layout.chargeDistance()            
# A.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

Alchemy::search = (instance)-&gt; 
    a = instance
    init: () -&gt;
        searchBox = a.dash
                     .select &quot;#search input&quot;

        searchBox.on &quot;keyup&quot;, ()-&gt;
            input = searchBox[0][0].value.toLowerCase()

            a.vis
             .selectAll &quot;.node&quot;
             .classed &quot;inactive&quot;, false
            a.vis
             .selectAll &quot;text&quot;
             .attr &quot;style&quot;, -&gt; &quot;display: inline;&quot; if input != &quot;&quot;
            a.vis
             .selectAll &quot;.node&quot;
             .classed &quot;inactive&quot;, (node) -&gt;
                DOMtext = d3.select @
                             .text()

                switch a.conf.searchMethod
                    when &#39;contains&#39;
                        hidden = DOMtext.toLowerCase().indexOf(input) &lt; 0
                    when &#39;begins&#39;
                        hidden = DOMtext.toLowerCase().indexOf(input) != 0

                if hidden
                     a.vis
                      .selectAll &quot;[source-target*=&#39;#{node.id}&#39;]&quot;
                      .classed &quot;inactive&quot;, hidden
                else
                     a.vis
                      .selectAll &quot;[source-target*=&#39;#{node.id}&#39;]&quot;
                      .classed &quot;inactive&quot;, (edge)-&gt; 
                          nodeIDs = [edge.source.id, edge.target.id]

                          sourceHidden = a.vis.select(&quot;#node-#{nodeIDs[0]}&quot;).classed &quot;inactive&quot;
                          targetHidden = a.vis.select(&quot;#node-#{nodeIDs[1]}&quot;).classed &quot;inactive&quot;

                          targetHidden or sourceHidden
                hidden
# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

Alchemy::startGraph = (instance) -&gt;
    a = instance

    (data) -&gt;
        conf = a.conf

        if d3.select(conf.divSelector).empty()
            console.warn a.utils.warnings.divWarning()

        # see if data is ok
        if not data
            a.utils.warnings.dataWarning()

        # create nodes map and update links
        a.create.nodes data.nodes

        data.edges.forEach (e) -&gt; a.create.edges e

        # create SVG
        a.vis = d3.select conf.divSelector
            .attr &quot;style&quot;, &quot;width:#{conf.graphWidth()}px; height:#{conf.graphHeight()}px; background:#{conf.backgroundColour};&quot;
            .append &quot;svg&quot;
                .attr &quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;
                .attr &quot;xlink&quot;, &quot;http://www.w3.org/1999/xlink&quot;
                .attr &quot;pointer-events&quot;, &quot;all&quot;
                .attr &quot;shape-rendering&quot;, &quot;optimizeSpeed&quot;
                .attr &quot;style&quot;, &quot;background:#{conf.backgroundColour};&quot;
                .attr &quot;alchInst&quot;, (d) -&gt; Alchemy::instances.length - 1
                .on &#39;click&#39;, a.interactions.deselectAll
                .call a.interactions.zoom(conf.scaleExtent)
                .on &quot;dblclick.zoom&quot;, null
                .append &#39;g&#39;
                    .attr &quot;transform&quot;,&quot;translate(#{conf.initialTranslate}) scale(#{conf.initialScale})&quot;

        # Create zoom event handlers
        a.interactions.zoom().scale conf.initialScale
        a.interactions.zoom().translate conf.initialTranslate

        a.generateLayout()
        a.controlDash.init()

        #enter/exit nodes/edges
        d3Edges = _.flatten _.map(a._edges, (edgeArray) -&gt; e._d3 for e in edgeArray)
        d3Nodes = _.map a._nodes, (n) -&gt; n._d3

        # if start
        a.layout.positionRootNodes()
        a.force.start()
        while a.force.alpha() &gt; 0.005
            a.force.tick()

        a._drawEdges = a.drawing.DrawEdges
        a._drawEdges.createEdge d3Edges
        a._drawNodes = a.drawing.DrawNodes
        a._drawNodes.createNode d3Nodes 

        initialComputationDone = true
        console.log Date() + &#39; completed initial computation&#39;

        nodes = a.vis.selectAll &#39;g.node&#39;
                        .attr &#39;transform&#39;, (id, i) -&gt; &quot;translate(#{id.x}, #{id.y})&quot;

        # configuration for forceLocked
        if !conf.forceLocked
            a.force
             .on &quot;tick&quot;, a.layout.tick
             .start()

        # call user-specified functions after load function if specified
        # deprecate?
        if conf.afterLoad?
            if typeof conf.afterLoad is &#39;function&#39;
                conf.afterLoad()
            else if typeof conf.afterLoad is &#39;string&#39;
                a[conf.afterLoad] = true

        if conf.cluster or conf.directedEdges
            defs = d3.select(&quot;#{a.conf.divSelector} svg&quot;).append &quot;svg:defs&quot;

        if conf.directedEdges
            arrowSize = conf.edgeArrowSize + (conf.edgeWidth() * 2)
            marker = defs.append &quot;svg:marker&quot;
                .attr &quot;id&quot;, &quot;arrow&quot;
                .attr &quot;viewBox&quot;, &quot;0 -#{arrowSize * 0.4} #{arrowSize} #{arrowSize}&quot;
                .attr &#39;markerUnits&#39;, &#39;userSpaceOnUse&#39;
                .attr &quot;markerWidth&quot;, arrowSize
                .attr &quot;markerHeight&quot;, arrowSize
                .attr &quot;orient&quot;, &quot;auto&quot;
            marker.append &quot;svg:path&quot;
                .attr &quot;d&quot;, &quot;M #{arrowSize},0 L 0,#{arrowSize * 0.4} L 0,-#{arrowSize * 0.4}&quot;
            if conf.curvedEdges
                marker.attr &quot;refX&quot;, arrowSize + 1
            else
                marker.attr &#39;refX&#39;, 1 

        if conf.nodeStats
            a.stats.nodeStats()

        if conf.showEditor
            editor = new a.editor.Editor
            editorInteractions = new a.editor.Interactions
            d3.select &quot;body&quot;
                .on &#39;keydown&#39;, editorInteractions.deleteSelected

            editor.startEditor()

# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

Alchemy::stats = (instance) -&gt;
    a = instance

    init: () -&gt; 
        a.stats.update()

    nodeStats: () -&gt;
        #general node stats
        nodeData = []

        allNodes = a.get.allNodes().length
        activeNodes = a.get.activeNodes().length
        inactiveNodes = allNodes - activeNodes

        nodeStats = &quot;&lt;li class = &#39;list-group-item gen_node_stat&#39;&gt;Number of nodes: &lt;span class=&#39;badge&#39;&gt;#{allNodes}&lt;/span&gt;&lt;/li&gt;           
                    &lt;li class = &#39;list-group-item gen_node_stat&#39;&gt;Number of active nodes: &lt;span class=&#39;badge&#39;&gt;#{activeNodes}&lt;/span&gt;&lt;/li&gt;
                    &lt;li class = &#39;list-group-item gen_node_stat&#39;&gt;Number of inactive nodes: &lt;span class=&#39;badge&#39;&gt;#{inactiveNodes}&lt;/span&gt;&lt;/li&gt;&lt;/br&gt;&quot;

        #add stats for all node types
        if a.conf.nodeTypes
            nodeKeys = Object.keys(a.conf.nodeTypes)
            nodeTypes = &#39;&#39;
            for nodeType in a.conf.nodeTypes[nodeKeys]
                caption = nodeType.replace(&#39;_&#39;, &#39; &#39;)
                nodeNum = a.vis.selectAll(&quot;g.node.#{nodeType}&quot;)[0].length
                nodeTypes += &quot;&lt;li class = &#39;list-group-item nodeType&#39; id=&#39;li-#{nodeType}&#39; 
                                name = #{caption}&gt;Number of &lt;strong style=&#39;text-transform: uppercase&#39;&gt;#{caption}&lt;/strong&gt; nodes: &lt;span class=&#39;badge&#39;&gt;#{nodeNum}&lt;/span&gt;&lt;/li&gt;&quot;
                nodeData.push([&quot;#{nodeType}&quot;, nodeNum])
            nodeStats += nodeTypes

        #add the graph
        nodeGraph = &quot;&lt;li id=&#39;node-stats-graph&#39; class=&#39;list-group-item&#39;&gt;&lt;/li&gt;&quot; 
        nodeStats += nodeGraph
        a.dash
               .select &#39;#node-stats&#39;
               .html nodeStats
        @insertSVG &quot;node&quot;, nodeData

    edgeStats: () -&gt;
        #general edge stats
        edgeData = []

        allEdges = a.get.allEdges().length
        activeEdges = a.get.activeEdges().length
        inactiveEdges = allEdges - activeEdges

        edgeStats = &quot;&lt;li class = &#39;list-group-item gen_edge_stat&#39;&gt;Number of relationships: &lt;span class=&#39;badge&#39;&gt;#{allEdges}&lt;/span&gt;&lt;/li&gt;
                    &lt;li class = &#39;list-group-item gen_edge_stat&#39;&gt;Number of active relationships: &lt;span class=&#39;badge&#39;&gt;#{activeEdges}&lt;/span&gt;&lt;/li&gt;
                    &lt;li class = &#39;list-group-item gen_edge_stat&#39;&gt;Number of inactive relationships: &lt;span class=&#39;badge&#39;&gt;#{inactiveEdges}&lt;/span&gt;&lt;/li&gt;&lt;/br&gt;&quot;

        #add stats for edge types
        if a.conf.edgeTypes
            edgeKeys = _.values(alchemy.conf.edgeTypes)[0]
            edgeTypes = &#39;&#39;
            for edgeType in edgeKeys
                if not edgeType then continue
                caption = edgeType.replace(&#39;_&#39;, &#39; &#39;)
                edgeNum = _.filter(a.get.allEdges(), (edge) -&gt; edge if edge._edgeType is edgeType).length
                edgeTypes += &quot;&lt;li class = &#39;list-group-item edgeType&#39; id=&#39;li-#{edgeType}&#39; 
                                name = #{caption}&gt;Number of &lt;strong style=&#39;text-transform: uppercase&#39;&gt;#{caption}&lt;/strong&gt; relationships: &lt;span class=&#39;badge&#39;&gt;#{edgeNum}&lt;/span&gt;&lt;/li&gt;&quot;                    
                edgeData.push([&quot;#{caption}&quot;, edgeNum])
            edgeStats += edgeTypes

        #add the graph
        edgeGraph = &quot;&lt;li id=&#39;node-stats-graph&#39; class=&#39;list-group-item&#39;&gt;&lt;/li&gt;&quot; 
        edgeStats += edgeGraph
        a.dash
               .select &#39;#rel-stats&#39;
               .html edgeStats 
        @insertSVG &quot;edge&quot;, edgeData


    insertSVG: (element, data) -&gt;
        if data is null 
            a.dash
                   .select &quot;##{element}-stats-graph&quot;
                   .html &quot;&lt;br&gt;&lt;h4 class=&#39;no-data&#39;&gt;There are no #{element}Types listed in your conf.&lt;/h4&gt;&quot;
        else
            width = a.conf.graphWidth() * .25
            height = 250
            radius = width / 4
            color = d3.scale.category20()

            arc = d3.svg.arc()
                .outerRadius(radius - 10)
                .innerRadius(radius/2)

            pie = d3.layout.pie()
                .sort(null)
                .value((d) -&gt; d[1])

            svg = a.dash
                         .select &quot;##{element}-stats-graph&quot;
                         .append &quot;svg&quot;
                         .append &quot;g&quot;
                         .style {&quot;width&quot;: width, &quot;height&quot;:height}
                         .attr &quot;transform&quot;, &quot;translate(&quot; + width/2 + &quot;,&quot; + height/2 + &quot;)&quot;

            arcs = svg.selectAll &quot;.arc&quot;
                .data pie(data)
                .enter()
                .append &quot;g&quot;
                .classed &quot;arc&quot;, true
                .on &quot;mouseover&quot;, (d,i) -&gt; 
                    a.dash
                      .select &quot;##{data[i][0]}-stat&quot;
                      .classed &quot;hidden&quot;, false
                .on &quot;mouseout&quot;, (d,i) -&gt; 
                    a.dash
                      .select &quot;##{data[i][0]}-stat&quot;
                      .classed &quot;hidden&quot;, true

            arcs.append &quot;path&quot;
                .attr &quot;d&quot;, arc
                .attr &quot;stroke&quot;, (d, i) -&gt; color(i)
                .attr &quot;stroke-width&quot;, 2
                .attr &quot;fill-opacity&quot;, &quot;0.3&quot;

            arcs.append &quot;text&quot;
                .attr &quot;transform&quot;, (d) -&gt; &quot;translate(&quot; + arc.centroid(d) + &quot;)&quot;
                .attr &quot;id&quot;, (d, i)-&gt; &quot;#{data[i][0]}-stat&quot;
                .attr &quot;dy&quot;, &quot;.35em&quot;
                .classed &quot;hidden&quot;, true
                .text (d, i) -&gt; data[i][0]

    update: () -&gt; 
        if a.conf.nodeStats then @nodeStats()
        if a.conf.edgeStats then @edgeStats()
# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

defaults =

    # Renderer
    renderer: &quot;svg&quot;

    # Layout
    graphWidth: -&gt;
        d3.select(@divSelector).node().parentElement.clientWidth
    graphHeight: -&gt;
        if d3.select(@divSelector).node().parentElement.nodeName is &quot;BODY&quot;
            window.innerHeight
        else 
            d3.select(@divSelector).node().parentElement.clientHeight
    alpha: 0.5
    collisionDetection: true
    nodeOverlap: 25
    fixNodes: false
    fixRootNodes: false
    forceLocked: true
    linkDistancefn: &#39;default&#39;
    nodePositions: null # not currently implemented

    # Editing
    showEditor: false # should change to nodeEditor and edgeEditor
    captionToggle: false
    toggleRootNodes: false
    removeElement: false

    #Clustering
    cluster: false
    clusterKey: &quot;cluster&quot;
    clusterColours: d3.shuffle [&quot;#DD79FF&quot;, &quot;#FFFC00&quot;,
                                &quot;#00FF30&quot;, &quot;#5168FF&quot;,
                                &quot;#00C0FF&quot;, &quot;#FF004B&quot;,
                                &quot;#00CDCD&quot;, &quot;#f83f00&quot;,
                                &quot;#f800df&quot;, &quot;#ff8d8f&quot;,
                                &quot;#ffcd00&quot;, &quot;#184fff&quot;,
                                &quot;#ff7e00&quot;]
    clusterControl: false

    #Stats
    nodeStats: false
    edgeStats: false

    # Filtering
    edgeFilters: false
    nodeFilters: false
    edgesToggle: false
    nodesToggle: false

    # Controls
    zoomControls: false

    # Nodes
    nodeCaption: &#39;caption&#39;
    nodeCaptionsOnByDefault: false
    nodeStyle:
        &quot;all&quot;:
            &quot;radius&quot;: 10
            &quot;color&quot;  : &quot;#68B9FE&quot;
            &quot;borderColor&quot;: &quot;#127DC1&quot;
            &quot;borderWidth&quot;: (d, radius) -&gt; radius / 3
            &quot;captionColor&quot;: &quot;#FFFFFF&quot;
            &quot;captionBackground&quot;: null
            &quot;captionSize&quot;: 12
            &quot;selected&quot;:
                &quot;color&quot; : &quot;#FFFFFF&quot;
                &quot;borderColor&quot;: &quot;#349FE3&quot;
            &quot;highlighted&quot;:
                &quot;color&quot; : &quot;#EEEEFF&quot;
            &quot;hidden&quot;:
                &quot;color&quot;: &quot;none&quot; 
                &quot;borderColor&quot;: &quot;none&quot;

    nodeColour: null # WILL BE DEPRECATED IN 1.0
    nodeMouseOver: &#39;caption&#39;
    nodeRadius: 10 # WILL BE DEPRECATED IN 1.0
    nodeTypes: null
    rootNodes: &#39;root&#39;
    rootNodeRadius: 15

    # Edges
    edgeCaption: &#39;caption&#39;
    edgeCaptionsOnByDefault: false
    edgeClick: &#39;default&#39;
    edgeStyle:
        &quot;all&quot;:
            &quot;width&quot;: 4
            &quot;color&quot;: &quot;#CCC&quot;
            &quot;opacity&quot;: 0.2
            &quot;directed&quot;: true
            &quot;curved&quot;: true
            &quot;selected&quot;:
                &quot;opacity&quot;: 1
            &quot;highlighted&quot;:
                &quot;opacity&quot;: 1
            &quot;hidden&quot;:
                &quot;opacity&quot;: 0
    edgeTypes: null
    curvedEdges: false
    edgeWidth: -&gt; 4
    edgeOverlayWidth: 20
    directedEdges: false
    edgeArrowSize: 5

    # Search
    search: false
    searchMethod: &quot;contains&quot;

    # Misc
    backgroundColour: &quot;#000000&quot;
    theme: null
    afterLoad: &#39;afterLoad&#39;
    divSelector: &#39;#alchemy&#39;
    dataSource: null
    initialScale: 1
    initialTranslate: [0,0]
    scaleExtent: [0.5, 2.4]
    exportSVG: false
    dataWarning: &quot;default&quot;
    warningMessage: &quot;There be no data!  What&#39;s going on?&quot;
# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

DrawEdge = (instance)-&gt;
    a: instance
    createLink: (edge) -&gt;
        conf = @a.conf
        curved = conf.curvedEdges
        directed = conf.directedEdges
        interactions = @a.interactions
        utils = @a.drawing.EdgeUtils

        edge.append &#39;path&#39;
            .attr &#39;class&#39;, &#39;edge-line&#39;
            .attr &#39;id&#39;, (d) -&gt; &quot;path-#{d.id}&quot;
        edge.filter (d) -&gt; d.caption?
            .append &#39;text&#39;
        edge.append &#39;path&#39;
            .attr &#39;class&#39;, &#39;edge-handler&#39;
            .style &#39;stroke-width&#39;, &quot;#{conf.edgeOverlayWidth}&quot;
            .style &#39;opacity&#39;, &quot;0&quot;

    styleLink: (edge) -&gt;
        a = @a
        conf = @a.conf
        directed = conf.directedEdges
        utils = @a.drawing.EdgeUtils
        edge.each (d) -&gt;
            edgeWalk = utils.edgeWalk d
            g = d3.select(@)
            g.style utils.edgeStyle d

            if !conf.curvedEdges #and !directed
                g.attr(&#39;transform&#39;, 
                   &quot;translate(#{edgeWalk.startEdgeX}, #{edgeWalk.startEdgeY}) rotate(#{edgeWalk.edgeAngle})&quot;)

            g.select(&#39;.edge-line&#39;)
             .attr &#39;d&#39;,</code></pre> <p><strong>This can be refactored for readability (please!)</strong> </p> <pre><code>            if conf.curvedEdges
                    angle = utils.edgeAngle d

                    sideOfY = if Math.abs(angle) &gt; 90 then -1 else 1
                    sideOfX = do (angle) -&gt;
                            return 0 if angle is 0
                            return if angle &lt; 0 then -1 else 1

                    startLine = utils.startLine(d)
                    endLine = utils.endLine(d)
                    sourceX = startLine.x
                    sourceY = startLine.y
                    targetX = endLine.x
                    targetY = endLine.y

                    dx = targetX - sourceX
                    dy = targetY - sourceY

                    hyp = Math.sqrt( dx * dx + dy * dy)

                    offsetX = (dx * conf.nodeRadius + 2) / hyp
                    offsetY = (dy * conf.nodeRadius + 2) / hyp

                    arrowX = (-sideOfX * ( conf.edgeArrowSize )) + offsetX
                    arrowY = ( sideOfY * ( conf.edgeArrowSize )) + offsetY
                    &quot;M #{startLine.x},#{startLine.y} A #{hyp}, #{hyp} #{utils.captionAngle(d)} 0, 1 #{endLine.x}, #{endLine.y}&quot;
                    # &quot;M #{sourceX-offsetX},#{sourceY-offsetY} A #{hyp}, #{hyp} #{utils.edgeAngle(d)} 0, 1 #{targetX - arrowX}, #{targetY - arrowY}&quot;

            else
                if conf.directedEdges

                    [&quot;M #{edgeWalk.startPathX} #{edgeWalk.startPathBottomY}&quot;
                     &quot;L #{edgeWalk.arrowBendX} #{edgeWalk.arrowBendBottomY}&quot;
                     &quot;L #{edgeWalk.arrowBendX} #{edgeWalk.arrowTipBottomY}&quot;
                     &quot;L #{edgeWalk.arrowEndX} #{edgeWalk.arrowEndY}&quot;
                     &quot;L #{edgeWalk.arrowBendX} #{edgeWalk.arrowTipTopY}&quot;
                     &quot;L #{edgeWalk.arrowBendX} #{edgeWalk.arrowBendTopY}&quot;
                     &quot;L #{edgeWalk.startPathX} #{edgeWalk.startPathTopY}&quot;
                     &quot;Z&quot;].join &quot; &quot;


                else
                    [&quot;M #{edgeWalk.startPathX} #{edgeWalk.startPathBottomY}&quot;
                     &quot;L #{edgeWalk.arrowEndX} #{edgeWalk.arrowBendBottomY}&quot;
                     &quot;L #{edgeWalk.arrowEndX} #{edgeWalk.arrowBendTopY}&quot;
                     &quot;L #{edgeWalk.startPathX} #{edgeWalk.startPathTopY}&quot;
                     &quot;Z&quot;].join &quot; &quot;

            g.select &#39;.edge-handler&#39;
                .attr &#39;d&#39;, (d) -&gt; g.select(&#39;.edge-line&#39;).attr(&#39;d&#39;)

    classEdge: (edge) -&gt;
        edge.classed &#39;active&#39;, true

    styleText: (edge) -&gt;
        conf = @a.conf
        curved = conf.curvedEdges
        directed = conf.directedEdges
        utils = @a.drawing.EdgeUtils

        if curved
            edge.select &#39;text&#39; 
                .each (d) -&gt;
                    edgeWalk = utils.edgeWalk d
                    d3.select(@).attr &#39;dx&#39;, (d) -&gt; utils.middlePath(d).x
                                .attr &#39;dy&#39;, (d) -&gt; utils.middlePath(d).y + 20
                                .attr &#39;transform&#39;, &quot;rotate(#{utils.captionAngle(d)})&quot;
                                .text d.caption
                                .style &quot;display&quot;, (d)-&gt; return &quot;block&quot; if conf.edgeCaptionsOnByDefault
        else
            edge.select &#39;text&#39;
                .each (d) -&gt;
                    edgeWalk = utils.edgeWalk d
                    captionAngle = utils.captionAngle(edgeWalk.edgeAngle)
                    if captionAngle is 180
                        dx = - edgeWalk.edgeLength / 2
                    else
                        dx = edgeWalk.edgeLength / 2
                    d3.select(@).attr &#39;dx&#39;, &quot;#{dx}&quot;
                                .attr &#39;dy&#39;, &quot;#{- d[&#39;stroke-width&#39;] * 1.1}&quot;
                                .attr &#39;transform&#39;, &quot;rotate(#{captionAngle})&quot;
                                .text d.caption
                                .style &quot;display&quot;, (d)-&gt;
                                    return &quot;block&quot; if conf.edgeCaptionsOnByDefault

        # TODO: Code to start having text follow path.
        # This will eliminate the need for alot of math and extra work if we can
        # simply get the text to xlink to the path itself.  It&#39;s not currently
        # working and we need to get on with the release, but it needs to be
        # implemented.
        #
        # edge.select &#39;text&#39;
        #     .each (d) -&gt;
        #         d3.select @
        #           .text d.caption
        #           .style &quot;display&quot;, (d)-&gt; return &quot;block&quot; if conf.edgeCaptionsOnByDefault
        #           .attr &quot;xlink:xlink:href&quot;, &quot;#path-#{d.source.id}-#{d.target.id}&quot;

    setInteractions: (edge) -&gt;
        interactions = @a.interactions
        # editorEnabled = @a.get.state(&quot;interactions&quot;) is &quot;editor&quot;
        # if editorEnabled
        #     editorInteractions = new @a.editor.Interactions
        #     edge.select &#39;.edge-handler&#39;
        #         .on &#39;click&#39;, editorInteractions.edgeClick
        # else
        edge.select &#39;.edge-handler&#39;
            .on &#39;click&#39;, interactions.edgeClick
            .on &#39;mouseover&#39;, (d)-&gt; interactions.edgeMouseOver(d)
            .on &#39;mouseout&#39;, (d)-&gt; interactions.edgeMouseOut(d)

# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

DrawEdges = (instance)-&gt;
    a: instance
    createEdge: (d3Edges) -&gt;
        drawEdge = @a.drawing.DrawEdge
        edge = @a.vis.selectAll &quot;g.edge&quot;
                        .data d3Edges
        edge.enter().append &#39;g&#39;
                    .attr &quot;id&quot;, (d) -&gt; &quot;edge-#{d.id}-#{d.pos}&quot;
                    .attr &#39;class&#39;, (d)-&gt;
                        &quot;edge #{d.edgeType}&quot;
                    .attr &#39;source-target&#39;, (d) -&gt; &quot;#{d.source.id}-#{d.target.id}&quot;    
        drawEdge.createLink edge
        drawEdge.classEdge edge
        drawEdge.styleLink edge
        drawEdge.styleText edge
        drawEdge.setInteractions edge
        edge.exit().remove()

        if @a.conf.directedEdges and @a.conf.curvedEdges
            edge.select(&#39;.edge-line&#39;)
                .attr(&#39;marker-end&#39;, &#39;url(#arrow)&#39;)

    updateEdge: (d3Edge) -&gt;
        drawEdge = @a.drawing.DrawEdge
        edge = @a.vis.select &quot;#edge-#{d3Edge.id}-#{d3Edge.pos}&quot;
        drawEdge.classEdge edge
        drawEdge.styleLink edge
        drawEdge.styleText edge
        drawEdge.setInteractions edge

# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

DrawNode = (instance)-&gt;
    a: instance
    styleText: (node) -&gt;
        conf = @a.conf
        utils = @a.drawing.NodeUtils
        nodes = @a._nodes
        node.selectAll &quot;text&quot;
            .attr &#39;dy&#39;, (d) -&gt;
                if nodes[d.id].getProperties().root
                    conf.rootNodeRadius / 2
                else
                    conf.nodeRadius * 2 - 5
            .attr &#39;visibility&#39;, (d) -&gt;
                if nodes[d.id]._state is &quot;hidden&quot;
                    &quot;hidden&quot;
                else
                    &quot;visible&quot;
            .html (d) -&gt; utils.nodeText(d)
            .style &quot;display&quot;, (d)-&gt;
                return &quot;block&quot; if conf.nodeCaptionsOnByDefault

    createNode: (node) -&gt;
        node.append &#39;circle&#39;
            .attr &#39;id&#39;, (d) -&gt; &quot;circle-#{d.id}&quot;
        node.append &#39;svg:text&#39;
            .attr &#39;id&#39;, (d) -&gt; &quot;text-#{d.id}&quot;

    styleNode: (node) -&gt;
        utils = @a.drawing.NodeUtils

        node.selectAll &#39;circle&#39;
            .attr &#39;r&#39;, (d) -&gt;
                if typeof d.radius is &quot;function&quot;
                    d.radius()
                else
                    d.radius
            .attr &#39;shape-rendering&#39;, &#39;optimizeSpeed&#39;
            .each (d) -&gt; d3.select(@).style utils.nodeStyle d


    setInteractions: (node) -&gt;
        conf = @a.conf
        coreInteractions = @a.interactions
        editorEnabled = @a.get.state(&quot;interactions&quot;) is &quot;editor&quot;

        # reset drag
        drag = d3.behavior.drag()
            .origin Object
            .on &quot;dragstart&quot;, null
            .on &quot;drag&quot;, null
            .on &quot;dragend&quot;, null

        if editorEnabled
            editorInteractions = new @a.editor.Interactions
            node.on &#39;mouseup&#39;,(d)-&gt;  editorInteractions.nodeMouseUp(d)
                .on &#39;mouseover&#39;, (d)-&gt; editorInteractions.nodeMouseOver(d)
                .on &#39;mouseout&#39;, (d)-&gt; editorInteractions.nodeMouseOut(d)
                .on &#39;dblclick&#39;, (d)-&gt; coreInteractions.nodeDoubleClick(d)
                .on &#39;click&#39;, (d)-&gt; editorInteractions.nodeClick(d)

        else
            node.on &#39;mouseup&#39;, null
                .on &#39;mouseover&#39;, (d)-&gt; coreInteractions.nodeMouseOver(d)
                .on &#39;mouseout&#39;, (d)-&gt; coreInteractions.nodeMouseOut(d)
                .on &#39;dblclick&#39;, (d)-&gt; coreInteractions.nodeDoubleClick(d)
                .on &#39;click&#39;, (d)-&gt; coreInteractions.nodeClick(d)

            drag = d3.behavior.drag()
                    .origin(Object)
                    .on &quot;dragstart&quot;, coreInteractions.nodeDragStarted
                    .on &quot;drag&quot;, coreInteractions.nodeDragged
                    .on &quot;dragend&quot;, coreInteractions.nodeDragended

            if not conf.fixNodes
                nonRootNodes = node.filter (d) -&gt; d.root isnt true
                nonRootNodes.call drag

            if not conf.fixRootNodes
                rootNodes = node.filter (d) -&gt; d.root is true
                rootNodes.call drag

# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

DrawNodes = (instance)-&gt;
    a: instance
    createNode: (d3Nodes) -&gt;
        drawNode = @a.drawing.DrawNode

        # alchemyNode is an array of one or more alchemyNode._d3 packets
        node = @a.vis.selectAll &quot;g.node&quot;
                 .data d3Nodes, (n) -&gt; n.id

        node.enter().append &quot;g&quot;
            .attr &quot;class&quot;, (d) -&gt;
                nodeType = d.self._nodeType
                &quot;node #{nodeType} active&quot;
            .attr &#39;id&#39;, (d) -&gt; &quot;node-#{d.id}&quot;
            .classed &#39;root&#39;, (d) -&gt; d.root

        drawNode.createNode node
        drawNode.styleNode node
        drawNode.styleText node
        drawNode.setInteractions node
        node.exit().remove()

    updateNode: (alchemyNode) -&gt;
        # alchemyNode is an array of one or more alchemyNode._d3 packets
        drawNode = @a.drawing.DrawNode
        node = @a.vis.select &quot;#node-#{alchemyNode.id}&quot;
        drawNode.styleNode node
        drawNode.styleText node
        drawNode.setInteractions node
# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

Alchemy::EdgeUtils = (instance)-&gt;
    a: instance
    edgeStyle: (d) -&gt;
        conf = @a.conf
        edge = @a._edges[d.id][d.pos]
        styles = @a.svgStyles.edge.update edge
        nodes = @a._nodes

        # edge styles based on clustering
        if @a.conf.cluster
            clustering = @a.layout._clustering
            styles.stroke = do (d) -&gt;
                clusterKey = conf.clusterKey
                source = nodes[d.source.id]._properties
                target = nodes[d.target.id]._properties
                if source.root or target.root
                    index = if source.root then target[clusterKey] else source[clusterKey]
                    &quot;#{clustering.getClusterColour(index)}&quot;
                else if source[clusterKey] is target[clusterKey]
                    index = source[clusterKey]
                    &quot;#{clustering.getClusterColour(index)}&quot;
                else if source[clusterKey] isnt target[clusterKey]
                    # use gradient between the two clusters&#39; colours
                    id = &quot;#{source[clusterKey]}-#{target[clusterKey]}&quot;
                    gid = &quot;cluster-gradient-#{id}&quot;
                    &quot;url(##{gid})&quot;

        styles

    triangle: (edge) -&gt;
        width = edge.target.x - edge.source.x
        height = edge.target.y - edge.source.y

        width: width
        height: height
        hyp: Math.sqrt height * height + width * width</code></pre> <p>This is the primary function used to draw the svg paths between two nodes for directed or undirected noncurved edges. </p> <pre><code>    edgeWalk: (edge) -&gt;
        arrowSize = @a.conf.edgeArrowSize
        arrowScale = 0.3</code></pre> <p>Build a right triangle.</p> <pre><code>        triangle = @triangle(edge)
        width  = triangle.width
        height = triangle.height
        hyp = triangle.hyp</code></pre> <p>The widht of the stroke places a large part in how the arrow lays out with larger edge widths.</p> <pre><code>        edgeWidth = edge[&#39;stroke-width&#39;]</code></pre> <p>After all of our calculations, we offset the edge by 2 pixels to account for the curve of the node. This typically is only noticable with opaque styles.</p> <pre><code>        curveOffset = 2</code></pre> <p>We start the edge at the very <em>edge</em> of the node, taking into account distances created by the stroke-width of the node and edge itself. The length of startPathX is then accounted for in the edgeLength.</p> <pre><code>        startPathX = 0 + edge.source.radius + edge.source[&#39;stroke-width&#39;] - (edgeWidth / 2) + curveOffset
        edgeLength = hyp - startPathX - curveOffset * 1.5</code></pre> <p>The absolute angle of the edge used for caption rendering and path rendering.</p> <pre><code>        edgeAngle: Math.atan2(height, width) / Math.PI * 180</code></pre> <p>The start of the edge in absolute coordinates. The start of the edge and end of the edge are simply the center of the source and target nodes.</p> <pre><code>        startEdgeX: edge.source.x
        startEdgeY: edge.source.y

        #endEdgeX: edge.target.x + (width * edge.target.radius + edge.target[&#39;stroke-width&#39;]) / hyp
        #endEdgeY: edge.target.y + (height * edge.target.radius + edge.target[&#39;stroke-width&#39;]) / hyp</code></pre> <p>The middle point of the edge, where the caption will be anchored.</p> <pre><code>        midLineX: edge.source.x + width / 2
        midLineY: edge.source.x + height / 2
        endLineX: edge.source.x + width / hyp
        endLineY: edge.source.x + height / hyp</code></pre> <p>Here we offset the start of the path to the very edge of the node by adding the stroke-width and the radius. Additionally, we account for the &#39;stroke-width&#39; of the edge itself, and then offeset that by one pixel to account for the curve of the node.</p> <pre><code>        startPathX: startPathX
        startPathBottomY: edgeWidth / 2

        arrowBendX: edgeLength - arrowSize
        arrowBendBottomY: edgeWidth / 2

        arrowTipBottomY: edgeWidth / 2 + (arrowSize * arrowScale)

        arrowEndX: edgeLength
        arrowEndY: 0

        arrowTipTopY: -(arrowSize * arrowScale + edgeWidth / 2)

        arrowBendTopY: - edgeWidth / 2

        startPathTopY: - edgeWidth / 2

        edgeLength: edgeLength

    # Temporary drop in to reimplement curved directed edges.
    # Will be replaced once the math for the better alternative is worked out.
    curvedDirectedEdgeWalk: (edge, point)-&gt;
        conf = @a.conf

        # build a right triangle
        width  = edge.target.x - edge.source.x
        height = edge.target.y - edge.source.y
        # as in hypotenuse 
        hyp = Math.sqrt(height * height + width * width)

        newpoint = if point is &#39;middle&#39;
                distance = (hyp / 2)
                x: edge.source.x + width * distance / hyp
                y: edge.source.y + height * distance / hyp
            else if point is &#39;linkStart&#39;
                distance = edge.source.radius+ edge.source[&#39;stroke-width&#39;]
                x: edge.source.x + width * distance / hyp
                y: edge.source.y + height * distance / hyp
            else if point is &#39;linkEnd&#39;
                if conf.curvedEdges
                    distance = hyp
                else
                    distance = hyp - (edge.target.radius + edge.target[&#39;stroke-width&#39;])
                if conf.directedEdges
                    distance = distance - conf.edgeArrowSize
                x: edge.source.x + width * distance / hyp
                y: edge.source.y + height * distance / hyp
        newpoint
    middleLine: (edge) -&gt; @curvedDirectedEdgeWalk edge, &#39;middle&#39;
    startLine: (edge) -&gt; @curvedDirectedEdgeWalk edge, &#39;linkStart&#39;
    endLine: (edge) -&gt; @curvedDirectedEdgeWalk edge, &#39;linkEnd&#39;

    edgeLength: (edge) -&gt;
        # build a right triangle
        width  = edge.target.x - edge.source.x
        height = edge.target.y - edge.source.y
        # as in hypotenuse 
        hyp = Math.sqrt(height * height + width * width)
    edgeAngle: (edge) -&gt;
        width  = edge.target.x - edge.source.x
        height = edge.target.y - edge.source.y
        Math.atan2(height, width) / Math.PI * 180

    captionAngle: (angle) -&gt;
        if angle &lt; -90 or angle &gt; 90
            180
        else
            0
    middlePath: (edge) -&gt;
        pathNode = @a.vis
                     .select &quot;#path-#{edge.id}&quot;
                     .node()
        midPoint = pathNode.getPointAtLength pathNode.getTotalLength()/2

        x: midPoint.x
        y: midPoint.y

    # Temporary fill in for curved edges until math is completed for new path only edges
    middlePathCurve: (edge) -&gt;
        pathNode = d3.select(&quot;#path-#{edge.id}&quot;).node()
        midPoint = pathNode.getPointAtLength(pathNode.getTotalLength()/2)

        x: midPoint.x
        y: midPoint.y
Alchemy::NodeUtils = (instance)-&gt;
        a = instance
        nodeStyle: (d) -&gt;
            conf = a.conf
            node = d.self
            if conf.cluster and (node._state isnt &quot;hidden&quot;)
                d.fill = do (d)-&gt;
                    clustering = a.layout._clustering
                    nodeProp = node.getProperties()
                    clusterMap = clustering.clusterMap
                    key = conf.clusterKey
                    colours = conf.clusterColours
                    # Modulo makes sure to reuse colors if it runs out
                    colourIndex = clusterMap[nodeProp[key]] % colours.length
                    colour = colours[colourIndex]
                    &quot;#{colour}&quot;
                d.stroke = d.fill
            d

        nodeText: (d) -&gt;
            conf = a.conf
            nodeProps = a._nodes[d.id]._properties
            if conf.nodeCaption and typeof conf.nodeCaption is &#39;string&#39;
                if nodeProps[conf.nodeCaption]?
                    nodeProps[conf.nodeCaption]
                else
                    &#39;&#39;
            else if conf.nodeCaption and typeof conf.nodeCaption is &#39;function&#39;
                caption = conf.nodeCaption(nodeProps)
                if caption is undefined or String(caption) is &#39;undefined&#39;
                    a.log[&quot;caption&quot;] = &quot;At least one caption returned undefined&quot;
                    conf.caption = false
                caption

Alchemy::svgStyles = (instance)-&gt;
    a: instance

    node:
        a: @a
        populate: (node) -&gt;
            conf = @a.conf
            defaultStyle = _.omit conf.nodeStyle.all, &quot;selected&quot;, &quot;highlighted&quot;, &quot;hidden&quot;
            d = node

            # if user put in hard value, turn into a function
            toFunc = (inp)-&gt;
                return inp if typeof inp is &quot;function&quot;
                return -&gt; inp

            nodeTypeKey = _.keys(conf.nodeTypes)[0]
            nodeType = node.getProperties()[nodeTypeKey]

            if conf.nodeStyle[nodeType] is undefined
                nodeType = &quot;all&quot;

            typedStyle = _.assign _.cloneDeep(defaultStyle), conf.nodeStyle[nodeType]
            style = _.assign typedStyle, conf.nodeStyle[nodeType][node._state]

            radius = toFunc style.radius
            fill = toFunc style.color
            stroke = toFunc style.borderColor
            strokeWidth = toFunc style.borderWidth

            svgStyles = {}
            svgStyles[&quot;radius&quot;] = radius d
            svgStyles[&quot;fill&quot;] = fill d
            svgStyles[&quot;stroke&quot;] = stroke d
            svgStyles[&quot;stroke-width&quot;] = strokeWidth d, radius(d)

            svgStyles

    edge:
        a: @a
        populate: (edge) -&gt;
            conf = @a.conf
            defaultStyle = _.omit conf.edgeStyle.all, &quot;selected&quot;, &quot;highlighted&quot;, &quot;hidden&quot;

            # if user put in hard value, turn into a function
            toFunc = (inp)-&gt;
                if typeof inp is &quot;function&quot;
                    return inp
                return -&gt; inp

            edgeType = edge._edgeType

            if conf.edgeStyle[edgeType] is undefined
                edgeType = &quot;all&quot;

            typedStyle = _.assign _.cloneDeep(defaultStyle), conf.edgeStyle[edgeType]
            style = _.assign typedStyle, conf.edgeStyle[edgeType][edge._state]

            width = toFunc style.width
            color = toFunc style.color
            opacity = toFunc style.opacity

            svgStyles =
                &quot;stroke&quot;: color edge
                &quot;stroke-width&quot;: width edge
                &quot;opacity&quot;: opacity edge
                &quot;fill&quot;: &quot;none&quot;
                # Uncomment for flower
                # &quot;fill&quot;: color edge

            svgStyles

        update: (edge) -&gt;
            conf = @a.conf
            style = edge._style
            toFunc = (inp)-&gt;
                if typeof inp is &quot;function&quot;
                    return inp
                return -&gt; inp

            width = toFunc style.width
            color = toFunc style.color
            opacity = toFunc style.opacity

            svgStyles =
                &quot;stroke&quot;: color edge
                &quot;stroke-width&quot;: width edge
                &quot;opacity&quot;: opacity edge
                &quot;fill&quot;: &quot;none&quot;

            svgStyles
# Alchemy.js is a graph drawing application for the web.
# Copyright (C) 2014  GraphAlchemist, Inc.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

class Editor
    constructor: -&gt;
        @utils = new alchemy.editor.Utils

    # init: =&gt;
    #     if alchemy.conf.showEditor is true
    #         @showOptions()
    #         @nodeEditorInit()
    #         @edgeEditorInit()

    editorContainerHTML:
            &quot;&quot;&quot;
                &lt;div id=&quot;editor-header&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#editor #element-options&quot;&gt;
                    &lt;h3&gt;Editor&lt;/h3&gt;&lt;span class=&quot;fa fa-2x fa-caret-right&quot;&gt;&lt;/span&gt;
                &lt;/div&gt;
                &lt;div id=&quot;element-options&quot; class=&quot;collapse&quot;&gt;
                    &lt;ul class=&quot;list-group&quot;&gt; 
                        &lt;li class=&quot;list-group-item&quot; id=&quot;remove&quot;&gt;Remove Selected&lt;/li&gt; 
                        &lt;li class=&quot;list-group-item&quot; id=&quot;editor-interactions&quot;&gt;Editor mode enabled, click to disable editor interactions&lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/div&gt;
                &quot;&quot;&quot;

    elementEditorHTML: (type) -&gt; 
            &quot;&quot;&quot;
                &lt;h4&gt;#{type} Editor&lt;/h4&gt;
                &lt;form id=&quot;add-property-form&quot;&gt;
                    &lt;div id=&quot;add-property&quot;&gt;
                        &lt;input class=&quot;form-control&quot; id=&quot;add-prop-key&quot; placeholder=&quot;New Property Name&quot;&gt;
                        &lt;input class=&quot;form-control&quot; id=&quot;add-prop-value&quot; placeholder=&quot;New Property Value&quot;&gt;
                    &lt;/div&gt;
                    &lt;input id=&quot;add-prop-submit&quot; type=&quot;submit&quot; value=&quot;Add Property&quot; placeholder=&quot;add a property to this node&quot;&gt;
                &lt;/form&gt;
                &lt;form id=&quot;properties-list&quot;&gt;
                    &lt;input id=&quot;update-properties&quot; type=&quot;submit&quot; value=&quot;Update Properties&quot;&gt;
                &lt;/form&gt;
            &quot;&quot;&quot;

    startEditor: =&gt;
        divSelector = alchemy.conf.divSelector
        html = @editorContainerHTML
        editor = alchemy.dash
                        .select &quot;#control-dash&quot;
                        .append &quot;div&quot;
                        .attr &quot;id&quot;, &quot;editor&quot;
                        .html html

        editor.select &#39;#editor-header&#39;
                .on &#39;click&#39;, () -&gt;
                    if alchemy.dash.select(&#39;#element-options&#39;).classed &quot;in&quot;
                        alchemy.dash
                               .select &quot;#editor-header&gt;span&quot;
                               .attr &quot;class&quot;, &quot;fa fa-2x fa-caret-right&quot;
                    else
                        alchemy.dash
                               .select &quot;#editor-header&gt;span&quot;
                               .attr &quot;class&quot;, &quot;fa fa-2x fa-caret-down&quot;   

        editor_interactions = editor.select &#39;#element-options ul #editor-interactions&#39;
            .on &#39;click&#39;, -&gt;
                d3.select @
                  .attr &quot;class&quot;, () -&gt;
                    if alchemy.get.state() is &#39;editor&#39;
                        alchemy.set.state &#39;interactions&#39;, &#39;default&#39;
                        &quot;inactive list-group-item&quot;
                    else
                        alchemy.set.state &#39;interactions&#39;, &#39;editor&#39;
                        &quot;active list-group-item&quot;
                  .html -&gt;
                      if alchemy.get.state() is &#39;editor&#39;
                          &quot;&quot;&quot;Disable Editor Interactions&quot;&quot;&quot;
                      else 
                          &quot;&quot;&quot;Enable Editor Interactions&quot;&quot;&quot;

        editor.select &quot;#element-options ul #remove&quot;
              .on &quot;click&quot;, -&gt; alchemy.editor.remove()

        utils = @utils

        editor_interactions.on &quot;click&quot;, () -&gt; 
                if !alchemy.dash.select(&quot;#editor-interactions&quot;).classed &quot;active&quot;
                    utils.enableEditor()
                    alchemy.dash.select &quot;#editor-interactions&quot;
                        .classed {&quot;active&quot;: true, &quot;inactive&quot;: false}
                        .html &quot;&quot;&quot;Editor mode enabled, click to disable editor interactions&quot;&quot;&quot;
                else 
                    utils.disableEditor()
                    alchemy.dash
                        .select &quot;#editor-interactions&quot;
                        .classed {&quot;active&quot;: false, &quot;inactive&quot;: true}
                        .html &quot;&quot;&quot;Editor mode disabled, click to enable editor interactions&quot;&quot;&quot;

    # nodeEditorInit: () -&gt;
    #     addPropHTML = &quot;&quot;&quot;
    #                     &lt;div id=&quot;add-property&quot;&gt;
    #                         &lt;input class=&#39;form-control&#39; id=&#39;node-add-prop-key&#39; placeholder=&quot;Property Name&quot;&gt;&lt;/input&gt;
    #                         &lt;input class=&#39;form-control&#39; id=&#39;node-add-prop-value&#39; placeholder=&quot;Property Value&quot;&gt;&lt;/input&gt;
    #                     &lt;/div&gt;
    #                 &quot;&quot;&quot;
    #     d3.select(&quot;#element-options&quot;)
    #         .append(&quot;div&quot;)
    #         .attr(&quot;id&quot;, &quot;node-editor&quot;)
    #         .attr(&quot;class&quot;, () -&gt;
    #             if d3.select(&quot;#editor-interactions&quot;).classed(&quot;active&quot;)
    #                 return &quot;enabled&quot;
    #             else return &quot;hidden&quot;
    #         )
    #         .html(&quot;&quot;&quot;&lt;h4&gt;Node Editor&lt;/h4&gt;&quot;&quot;&quot;)

    #     # node editor form and add property form
    #     d3.select(&quot;#node-editor&quot;)
    #         .append(&quot;form&quot;)
    #         .attr(&quot;id&quot;, &quot;node-add-property&quot;)
    #         .html(addPropHTML)

    #     d3.select(&quot;#node-add-property&quot;)
    #         .append(&quot;input&quot;)
    #         .attr(&quot;id&quot;, &quot;node-add-prop-submit&quot;)
    #         .attr(&quot;type&quot;, &quot;submit&quot;)
    #         .attr(&quot;value&quot;, &quot;Add Property&quot;)

    #     # submission handler
    #     d3.select(&quot;#node-add-property&quot;)
    #         .on &quot;submit&quot; , -&gt;
    #             event.preventDefault()
    #             if d3.select(&quot;.node.selected&quot;).empty()
    #                 d3.selectAll(&quot;#node-add-prop-value, #node-add-prop-key&quot;)
    #                     .attr(&quot;placeholder&quot;, &quot;select a node first&quot;)

    nodeEditor: (n) =&gt;
        divSelector = alchemy.conf.divSelector        
        editor = alchemy.dash.select &quot;#control-dash #editor&quot;
        options = editor.select &#39;#element-options&#39;
        # options.html(html)
        html = @elementEditorHTML &quot;Node&quot;
        elementEditor = options.append &#39;div&#39;
                                .attr &#39;id&#39;, &#39;node-editor&#39;
                                .html html

        elementEditor.attr &quot;class&quot;, () -&gt;
                    active = alchemy.dash
                                    .select &quot;#editor-interactions&quot;
                                    .classed &quot;active&quot;
                    return &quot;enabled&quot; if active
                    &quot;hidden&quot;

        add_property = editor.select &quot;#node-editor form #add-property&quot;
        add_property.select &quot;#node-add-prop-key&quot;
                    .attr &quot;placeholder&quot;, &quot;New Property Name&quot;
                    .attr &quot;value&quot;, null
        add_property.select &quot;#node-add-prop-value&quot;
                    .attr &quot;placeholder&quot;, &quot;New Property Value&quot;
                    .attr &quot;value&quot;, null

        alchemy.dash
            .select &quot;#add-property-form&quot;
            .on &quot;submit&quot;, -&gt;
                event.preventDefault()
                key = alchemy.dash
                             .select &#39;#add-prop-key&#39;
                             .property &#39;value&#39;
                key = key.replace /\s/g, &quot;_&quot;
                value = alchemy.dash
                               .select &#39;#add-prop-value&#39;
                               .property &#39;value&#39;
                updateProperty key, value, true
                alchemy.dash
                       .selectAll &quot;#add-property .edited-property&quot;
                       .classed &quot;edited-property&quot;:false
                @reset()

        nodeProperties = alchemy._nodes[n.id].getProperties()
        alchemy.vis
               .select &quot;#node-#{n.id}&quot;
               .classed &quot;editing&quot;:true

        property_list = editor.select &quot;#node-editor #properties-list&quot;

        for property, val of nodeProperties
            node_property = property_list.append &quot;div&quot;
                                         .attr &quot;id&quot;, &quot;node-#{property}&quot;
                                         .attr &quot;class&quot;, &quot;property form-inline form-group&quot;

            node_property.append &quot;label&quot;
                            .attr &quot;for&quot;, &quot;node-#{property}-input&quot;
                            .attr &quot;class&quot;,&quot;form-control property-name&quot;
                            .text &quot;#{property}&quot;

            node_property.append &quot;input&quot;
                            .attr &quot;id&quot;, &quot;node-#{property}-input&quot;
                            .attr &quot;class&quot;, &quot;form-control property-value&quot;
                            .attr &quot;value&quot;, &quot;#{val}&quot;

        alchemy.dash
               .select &quot;#properties-list&quot;
               .on &quot;submit&quot;, -&gt; 
                   event.preventDefault()
                   properties = alchemy.dash.selectAll &quot;.edited-property&quot;
                   for property in properties[0]
                       selection = alchemy.dash.select property
                       key = selection.select(&quot;label&quot;).text()
                       value = selection.select(&quot;input&quot;).attr &#39;value&#39;
                       updateProperty key, value, false
                   alchemy.dash
                          .selectAll &quot;#node-properties-list .edited-property&quot;
                          .classed &quot;edited-property&quot;:false
                   @.reset()

        d3.selectAll &quot;#add-prop-key, #add-prop-value, .property&quot;
            .on &quot;keydown&quot;, -&gt;
                if d3.event.keyCode is 13
                    event.preventDefault()
                d3.select(@).classed {&quot;edited-property&quot;:true}

        updateProperty = (key, value, newProperty) -&gt;
            nodeID = n.id
            if (key!=&quot;&quot;) and (value != &quot;&quot;)
                alchemy._nodes[nodeID].setProperty &quot;#{key}&quot;, &quot;#{value}&quot;
                drawNodes = alchemy._drawNodes
                drawNodes.updateNode alchemy.viz.select(&quot;#node-#{nodeID}&quot;)
                if newProperty is true 
                    alchemy.dash
                           .select &quot;#node-add-prop-key&quot;
                           .attr &quot;value&quot;, &quot;property added/updated to key: #{key}&quot;
                    alchemy.dash
                           .select &quot;#node-add-prop-value&quot;
                           .attr &quot;value&quot;, &quot;property at #{key} updated to: #{value}&quot;
                else
                    alchemy.dash
                           .select &quot;#node-#{key}-input&quot;
                           .attr &quot;value&quot;, &quot;property at #{key} updated to: #{value}&quot;

            else
                if newProperty is true 
                    alchemy.dash
                           .select &quot;#node-add-prop-key&quot;
                           .attr &quot;value&quot;, &quot;null or invalid input&quot;
                    alchemy.dash
                           .select &quot;#node-add-prop-value&quot;
                           .attr &quot;value&quot;, &quot;null or invlid input&quot;
                else
                    alchemy.dash
                           .select &quot;#node-#{key}-input&quot;
                           .attr &quot;value&quot;, &quot;null or invalid input&quot;

    editorClear: () -&gt;
        alchemy.dash
               .selectAll &quot;.node&quot;
               .classed &quot;editing&quot;:false
        alchemy.dash
               .selectAll &quot;.edge&quot;
               .classed &quot;editing&quot;:false
        alchemy.dash
               .select &quot;#node-editor&quot;
               .remove()
        alchemy.dash
               .select &quot;#edge-editor&quot;
               .remove()
        alchemy.dash
               .select &quot;#node-add-prop-submit&quot;
               .attr &quot;placeholder&quot;, ()-&gt;
                   if alchemy.vis.selectAll(&quot;.selected&quot;).empty()
                       return &quot;select a node or edge to edit properties&quot;
                   return &quot;add a property to this element&quot;

    edgeEditor: (e) -&gt;
        divSelector = alchemy.conf.divSelector        
        editor = alchemy.dash &quot;#control-dash #editor&quot;
        options = editor.select &#39;#element-options&#39;
        html = @elementEditorHTML &quot;Edge&quot;
        elementEditor = options.append &#39;div&#39;
                                .attr &#39;id&#39;, &#39;edge-editor&#39;
                                .html html

        elementEditor.attr &quot;class&quot;, () -&gt;
                    return &quot;enabled&quot; if alchemy.dash
                                               .select &quot;#editor-interactions&quot;
                                               .classed &quot;active&quot;
                    &quot;hidden&quot;

        add_property = editor.select &quot;#edge-editor form #add-property&quot;
        add_property.select &quot;#add-prop-key&quot;
                    .attr &quot;placeholder&quot;, &quot;New Property Name&quot;
                    .attr &quot;value&quot;, null
        add_property.select &quot;#add-prop-value&quot;
                    .attr &quot;placeholder&quot;, &quot;New Property Value&quot;
                    .attr &quot;value&quot;, null

        edgeProperties = alchemy._edges[e.id].getProperties()
        alchemy.vis
               .select &quot;#edge-#{e.id}&quot;
               .classed &quot;editing&quot;:true

        property_list = editor.select &quot;#edge-editor #properties-list&quot;

        for property, val of edgeProperties
            edge_property = property_list.append &quot;div&quot;
                                            .attr &quot;id&quot;, &quot;edge-#{property}&quot;
                                            .attr &quot;class&quot;, &quot;property form-inline form-group&quot;

            edge_property.append &quot;label&quot;
                            .attr &quot;for&quot;, &quot;edge-#{property}-input&quot;
                            .attr &quot;class&quot;,&quot;form-control property-name&quot;
                            .text &quot;#{property}&quot;

            edge_property.append &quot;input&quot;
                            .attr &quot;id&quot;, &quot;edge-#{property}-input&quot;
                            .attr &quot;class&quot;, &quot;form-control property-value&quot;
                            .attr &quot;value&quot;, &quot;#{val}&quot;

        alchemy.dash
               .selectAll &quot;#add-prop-key, #add-prop-value, .property&quot;
               .on &quot;keydown&quot;, -&gt;
                   if d3.event.keyCode is 13
                       event.preventDefault()
                   d3.select(@).classed {&quot;edited-property&quot;:true}

        alchemy.dash
            .select &quot;#add-property-form&quot;
            .on &quot;submit&quot;, -&gt;
                event.preventDefault()
                key = alchemy.dash
                             .select &quot;#add-prop-key&quot;
                             .property &#39;value&#39;
                key = key.replace /\s/g, &quot;_&quot;
                value = alchemy.dash
                               .select &quot;#add-prop-value&quot;
                               .property &#39;value&#39;
                updateProperty key, value, true

                alchemy.dash
                       .selectAll &quot;#add-property .edited-property&quot;
                       .classed &quot;edited-property&quot;:false
                @reset()

        d3.select &quot;#properties-list&quot;
            .on &quot;submit&quot;, -&gt; 
                event.preventDefault()
                properties = alchemy.dash.selectAll &quot;.edited-property&quot;
                for property in properties[0]
                    selection = alchemy.dash.select property
                    key = selection.select(&quot;label&quot;).text()
                    value = selection.select(&quot;input&quot;).property &#39;value&#39;
                    updateProperty key, value, false

                alchemy.dash
                       .selectAll &quot;#properties-list .edited-property&quot;
                       .classed &quot;edited-property&quot;:false
                @reset()

        updateProperty = (key, value, newProperty) -&gt;
            edgeID = e.id
            if (key!=&quot;&quot;) and (value != &quot;&quot;)
                alchemy._edges[edgeID].setProperty &quot;#{key}&quot;, &quot;#{value}&quot;
                edgeSelection = alchemy.vis.select &quot;#edge-#{edgeID}&quot;
                drawEdges = new alchemy.drawing.DrawEdges
                drawEdges.updateEdge alchemy.vis.select(&quot;#edge-#{edgeID}&quot;)
                if newProperty is true 
                    alchemy.dash
                           .select &quot;#add-prop-key&quot;
                           .attr &quot;value&quot;, &quot;property added/updated to key: #{key}&quot;
                    alchemy.dash
                           .select &quot;#add-prop-value&quot;
                           .attr &quot;value&quot;, &quot;property at #{key} updated to: #{value}&quot;
                else
                    alchemy.dash
                           .select &quot;#edge-#{key}-input&quot;
                           .attr &quot;value&quot;, &quot;property at #{key} updated to: #{value}&quot;

            else
                if newProperty is true 
                    alchemy.dash
                           .select &quot;#add-prop-key&quot;
                           .attr &quot;value&quot;, &quot;null or invalid input&quot;
                    alchemy.dash
                           .select &quot;#add-prop-value&quot;
                           .attr &quot;value&quot;, &quot;null or invlid input&quot;
                else
                    alchemy.dash
                           .select &quot;#edge-#{key}-input&quot;
                           .attr &quot;value&quot;, &quot;null or invalid input&quot;
class EditorInteractions
    # @mouseUpNode = null
    # @sourceNode = null
    # @targetNode = null
    # @newEdge = null
    # @click = null
    constructor: -&gt;
        @editor = new alchemy.editor.Editor

    nodeMouseOver: (n) -&gt;
        if !d3.select(@).select(&quot;circle&quot;).empty()
            radius = d3.select @
                       .select &quot;circle&quot;
                       .attr &quot;r&quot;
            d3.select @
              .select &quot;circle&quot;
                .attr &quot;r&quot;, radius*3
        @

    nodeMouseUp: (n) =&gt;
        if @sourceNode != n
            @mouseUpNode = true
            @targetNode = n
            @click = false
        else 
            @click = true
        @

    nodeMouseOut: (n) -&gt;
        if !d3.select(@).select(&quot;circle&quot;).empty()
            radius = d3.select @
                       .select &quot;circle&quot;
                       .attr &quot;r&quot;
            d3.select @
              .select &quot;circle&quot;
              .attr &quot;r&quot;, radius/3
        @

    nodeClick: (c) =&gt;
        d3.event.stopPropagation()
        # select the correct nodes
        if !alchemy.vis.select(&quot;#node-#{c.id}&quot;).empty()
            selected = alchemy.vis
                              .select &quot;#node-#{c.id}&quot;
                              .classed &#39;selected&#39;
            alchemy.vis
                   .select &quot;#node-#{c.id}&quot;
                   .classed &#39;selected&#39;, !selected
        @editor.editorClear()
        @editor.nodeEditor c

    edgeClick: (e) =&gt;
        d3.event.stopPropagation()
        @editor.editorClear()
        @editor.edgeEditor e

    addNodeStart: (d, i) =&gt;
        d3.event.sourceEvent.stopPropagation()
        @sourceNode = d
        alchemy.vis
            .select &#39;#dragline&#39;
            .classed &quot;hidden&quot;:false
        @

    addNodeDragging: (d, i) =&gt;
        # rework
        x2coord = d3.event.x
        y2coord = d3.event.y
        alchemy.vis
            .select &#39;#dragline&#39;
            .attr &quot;x1&quot;, @sourceNode.x
            .attr &quot;y1&quot;, @sourceNode.y
            .attr &quot;x2&quot;, x2coord
            .attr &quot;y2&quot;, y2coord
            .attr &quot;style&quot;, &quot;stroke: #FFF&quot;
        @


    addNodeDragended: (d, i) =&gt;
        #we moused up on an existing (different) node
        if !@click 
            if !@mouseUpNode
                dragline = alchemy.vis.select &quot;#dragline&quot;
                targetX = dragline.attr &quot;x2&quot;
                targetY = dragline.attr &quot;y2&quot;

                @targetNode =
                    id: &quot;#{_.uniqueId(&#39;addedNode_&#39;)}&quot;,
                    x: parseFloat(targetX),
                    y: parseFloat(targetY),
                    caption: &quot;node added&quot;

            @newEdge =
                id: &quot;#{@sourceNode.id}-#{@targetNode.id}&quot;, 
                source: @sourceNode.id, 
                target: @targetNode.id, 
                caption: &quot;edited&quot;

            alchemy.editor.update @targetNode, @newEdge

        @reset()
        @

    deleteSelected: (d) =&gt;
        switch d3.event.keyCode
            when 8, 46
                if !(d3.select(d3.event.target).node().tagName is (&quot;INPUT&quot; or &quot;TEXTAREA&quot;))
                    d3.event.preventDefault()
                    alchemy.editor.remove()

    reset: =&gt;
        # reset interaciton variables
        @mouseUpNode = null
        @sourceNode = null
        @targetNode = null
        @newEdge = null
        @click = null

        #reset dragline
        alchemy.vis
            .select &quot;#dragline&quot;
            .classed &quot;hidden&quot;:true
            .attr &quot;x1&quot;, 0            
            .attr &quot;y1&quot;, 0
            .attr &quot;x2&quot;, 0
            .attr &quot;y2&quot;, 0 
        @

    @

class EditorUtils
    constructor: () -&gt;
        @drawNodes = alchemy._drawNodes
        @drawEdges = alchemy._drawEdges

    enableEditor: () =&gt;
        alchemy.set.state &quot;interactions&quot;, &quot;editor&quot;
        dragLine = alchemy.vis
            .append &quot;line&quot;
            .attr &quot;id&quot;, &quot;dragline&quot;

        @drawNodes.updateNode alchemy.node
        @drawEdges.updateEdge alchemy.edge
        selectedElements = alchemy.vis.selectAll &quot;.selected&quot;
        editor = new alchemy.editor.Editor
        if (not selectedElements.empty()) and (selectedElements.length is 1)
            if selectedElements.classed &#39;node&#39;
                editor.nodeEditor selectedElements.datum()
                alchemy.dash
                    .select &quot;#node-editor&quot;
                    .attr &quot;class&quot;, &quot;enabled&quot;
                    .style &quot;opacity&quot;, 1
            else if selectedElements.classed &#39;edge&#39;
                editor.edgeEditor selectedElements.datum()
                alchemy.dash
                    .select &quot;#edge-editor&quot;
                    .attr &quot;class&quot;, &quot;enabled&quot;
                    .style &quot;opacity&quot;, 1
        else
            selectedElements.classed &quot;selected&quot;:false

    disableEditor: () -&gt;
        alchemy.setState &quot;interactions&quot;, &quot;default&quot;
        alchemy.vis
               .select &quot;#dragline&quot;
               .remove()

        alchemy.dash
               .select &quot;#node-editor&quot;
               .transition()
               .duration 300
               .style &quot;opacity&quot;, 0
        alchemy.dash
               .select &quot;#node-editor&quot;
               .transition()
               .delay 300
               .attr &quot;class&quot;, &quot;hidden&quot;

        @drawNodes.updateNode alchemy.node
        alchemy.vis
               .selectAll &quot;.node&quot;
               .classed &quot;selected&quot;:false

    remove: () -&gt;
        selectedNodes = alchemy.vis.selectAll &quot;.selected.node&quot;
        for node in selectedNodes[0]
            nodeID = alchemy.vis
                            .select node
                            .data()[0]
                            .id

            node_data = alchemy._nodes[nodeID]
            if node_data?
                for edge in node_data.adjacentEdges
                    alchemy._edges = _.omit alchemy._edges, &quot;#{edge.id}-#{edge._index}&quot;
                    alchemy.edge = alchemy.edge.data _.map(alchemy._edges, (e) -&gt; e._d3), (e)-&gt;e.id
                    alchemy.vis
                           .select &quot;#edge-#{edge.id}-#{edge._index}&quot;
                           .remove()
                alchemy._nodes = _.omit alchemy._nodes, &quot;#{nodeID}&quot;
                alchemy.node = alchemy.node.data _.map(alchemy._nodes, (n) -&gt; n._d3), (n)-&gt;n.id
                alchemy.vis
                       .select node
                       .remove()
                if alchemy.get.state(&quot;interactions&quot;) is &quot;editor&quot;
                    alchemy.modifyElements.nodeEditorClear()

    addNode: (node) -&gt;
        newNode = alchemy._nodes[node.id] = new alchemy.models.Node {id:&quot;#{node.id}&quot;}
        newNode.setProperty &quot;caption&quot;, node.caption
        newNode.setD3Property &quot;x&quot;, node.x
        newNode.setD3Property &quot;y&quot;, node.y
        alchemy.node = alchemy.node.data _.map(alchemy._nodes, (n) -&gt; n._d3), (n)-&gt;n.id

    addEdge: (edge) -&gt;
        newEdge = alchemy._edges[edge.id] = new alchemy.models.Edge edge
        alchemy.edge = alchemy.edge.data _.map(alchemy._edges, (e) -&gt; e._d3), (e)-&gt;e.id

    update: (node, edge) -&gt;
        #only push the node if it didn&#39;t previously exist
        if !@mouseUpNode
            alchemy.editor.addNode node
            alchemy.editor.addEdge edge
            @drawEdges.createEdge alchemy.edge
            @drawNodes.createNode alchemy.node

        else
            alchemy.editor.addEdge edge
            @drawEdges.createEdge alchemy.edge

        alchemy.layout.tick()

Alchemy::Edge = (instance)-&gt;
    class Edge
        # takes an edge property map from GraphJSON
        # as well as an index, which is the position of the edge map in
        # the array of edges stored in @a._edges at each &quot;source-target&quot;
        # this is used to create the id for the individual node which will be &quot;source-target-index&quot;
        # e.g. 1-0-1
        constructor: (edge, index=null) -&gt;
            @a = instance
            conf = @a.conf

            @id = @_setID edge
            @_index = index
            @_state = &quot;active&quot;
            @_properties = edge
            @_edgeType = @_setEdgeType()
            @_style =
                if conf.edgeStyle[@_edgeType]?
                    _.merge _.clone(conf.edgeStyle[&quot;all&quot;]), conf.edgeStyle[@_edgeType]
                else
                    _.clone conf.edgeStyle[&quot;all&quot;]
            @_d3 = _.merge
                &#39;id&#39;: @id
                &#39;pos&#39;: @_index
                &#39;edgeType&#39;: @_edgeType
                &#39;source&#39;: @a._nodes[@_properties.source]._d3
                &#39;target&#39;: @a._nodes[@_properties.target]._d3
                &#39;self&#39;: @
                , @a.svgStyles.edge.populate @
            @_setCaption(edge, conf)
            # Add id to source/target&#39;s edgelist
            @a._nodes[&quot;#{edge.source}&quot;]._addEdge @
            @a._nodes[&quot;#{edge.target}&quot;]._addEdge @

        _setD3Properties: (props) =&gt; _.merge @_d3, props

        _setID: (e) =&gt; if e.id? then e.id else &quot;#{e.source}-#{e.target}&quot;

        _setCaption: (edge, conf) =&gt;
            cap = conf.edgeCaption
            edgeCaption = do (edge) -&gt;
                switch typeof cap
                    when (&#39;string&#39; or &#39;number&#39;) then edge[cap]
                    when &#39;function&#39; then cap(edge)
            if edgeCaption
                @_d3.caption = edgeCaption

        _setEdgeType: -&gt;
            conf = @a.conf
            if conf.edgeTypes
                if _.isPlainObject conf.edgeTypes
                    lookup = Object.keys @a.conf.edgeTypes
                    edgeType = @_properties[lookup]
                else if _.isArray conf.edgeTypes
                    edgeType = @_properties[&quot;caption&quot;]
                else if typeof conf.edgeTypes is &#39;string&#39;
                    edgeType = @_properties[conf.edgeTypes]
            if edgeType is undefined then edgeType = &quot;all&quot;
            @_setD3Properties &#39;edgeType&#39;, edgeType
            edgeType

        getProperties: (key=null, keys...) =&gt;
            if not key? and (keys.length is 0)
                @_properties
            else if keys.length isnt 0
                query = _.union [key], keys
                _.pick @_properties, query
            else
                @_properties[key]

        setProperties: (property, value=null) =&gt;
            if _.isPlainObject property
                _.assign @_properties, property
                if &#39;source&#39; of property then @_setD3Properties {&#39;source&#39;: alchemy._nodes[property.source]._d3}
                if &#39;target&#39; of property then @_setD3Properties {&#39;target&#39;: alchemy._nodes[property.target]._d3}
            else
                @_properties[property] = value
                if (property is &#39;source&#39;) or (property is &#39;target&#39;)
                    @_setD3Properties {property: alchemy._nodes[value]._d3}
            @

        getStyles: (key=null, keys...) =&gt;
            if not key? and (keys.length is 0)
                @_style
            else if keys.length isnt 0
                query = _.union [key], keys
                _.pick @_style, query
            else
                @_style[key]

        setProperties: (property, value=null) =&gt;
            if _.isPlainObject property
                _.assign @_properties, property
                if &#39;source&#39; of property then @_setD3Properties {&#39;source&#39;: @a._nodes[property.source]._d3}
                if &#39;target&#39; of property then @_setD3Properties {&#39;target&#39;: @a._nodes[property.target]._d3}
            else
                @_properties[property] = value
                if (property is &#39;source&#39;) or (property is &#39;target&#39;)
                    @_setD3Properties {property: @a._nodes[value]._d3}
            @

        setStyles: (key, value=null) -&gt;
            # If undefined, set styles based on state
            if key is undefined
                key = @a.svgStyles.edge.populate @

            # takes a key, value or map of key values
            # the user passes a map of styles to set multiple styles at once
            if _.isPlainObject key
                _.assign @_style, key
            else if typeof key is &quot;string&quot;
                @_style[key] = value

            @_setD3Properties @a.svgStyles.edge.update(@)
            @a._drawEdges.updateEdge @_d3
            @

        toggleHidden: ()-&gt;
            @._state = if @._state is &quot;hidden&quot; then &quot;active&quot; else &quot;hidden&quot;
            @.setStyles()

        allNodesActive: () =&gt;
            sourceId = @_properties.source
            targetId = @_properties.target
            sourceNode = alchemy.get.nodes(sourceId)[0]
            targetNode = alchemy.get.nodes(targetId)[0]
            sourceNode._state is &quot;active&quot; and targetNode._state is &quot;active&quot;

        remove: -&gt;
            delete @a._edges[@.id]
            @a.vis.select(&quot;#edge-&quot; + @.id + &quot;-&quot; + @._index).remove()
            filteredLinkList = _.filter @a.force.links(), (link) -&gt; link if link.id != @.id
            @a.force.links(filteredLinkList)

Alchemy::Node = (instance)-&gt;
    class Node
        constructor: (node) -&gt;
            @a = instance
            conf = @a.conf

            @id = node.id
            @_properties = node
            @_d3 = _.merge
                &#39;id&#39;: @id
                &#39;root&#39;: @_properties[conf.rootNodes]
                &#39;self&#39;: @
                , @a.svgStyles.node.populate @
            @_nodeType = @_setNodeType()
            @_style =
                if conf.nodeStyle[@_nodeType]
                    conf.nodeStyle[@_nodeType]
                else
                    conf.nodeStyle[&quot;all&quot;]
            @_state = &quot;active&quot;

            @_adjacentEdges = []

        # internal methods
        _setNodeType: =&gt;
            conf = @a.conf
            if conf.nodeTypes
                if _.isPlainObject conf.nodeTypes
                    lookup = Object.keys @a.conf.nodeTypes
                    types = _.values conf.nodeTypes
                    nodeType = @_properties[lookup]
                else if typeof conf.nodeTypes is &#39;string&#39;
                    nodeType = @_properties[conf.nodeTypes]
            if nodeType is undefined then nodeType = &quot;all&quot;
            @_setD3Properties &#39;nodeType&#39;, nodeType
            nodeType

        _setD3Properties: (props) =&gt;
            _.merge @_d3, props

        _addEdge: (edge) -&gt;
            # Stores edge.id for easy edge lookup
            @_adjacentEdges = _.union @_adjacentEdges, [edge]

        # Edit node properties
        getProperties: (key=null, keys...) =&gt;
            if not key? and (keys.length is 0)
                @_properties
            else if keys.length isnt 0
                query = _.union [key], keys
                _.pick @_properties, query
            else
                @_properties[key]

        setProperty: (property, value=null) =&gt;
            if _.isPlainObject property
                _.assign @_properties, property
            else
                @_properties[property] = value
            @

        removeProperty: (property) -&gt;
            delete @_properties[property]
            @


        # Style methods
        getStyles: (key=null) =&gt;
            if key?
                @_style[key]
            else
                @_style

        setStyles: (key, value=null) -&gt;
            # If undefined, set styles based on state
            if key is undefined
                key = @a.svgStyles.node.populate @
            # takes a key, value or map of key values
            # the user passes a map of styles to set multiple styles at once
            else if _.isPlainObject key
                _.assign @_style, key
            else
                @_style[key] = value
            @_setD3Properties @a.svgStyles.node.populate @
            @a._drawNodes.updateNode @_d3
            @

        toggleHidden: -&gt;
            a = @a
            @_state = if @_state is &quot;hidden&quot; then &quot;active&quot; else &quot;hidden&quot;
            @setStyles()

            _.each @_adjacentEdges, (e)-&gt;
                [source, target] = e.id.split(&quot;-&quot;)
                sourceState = a._nodes[&quot;#{source}&quot;]._state
                targetState = a._nodes[&quot;#{target}&quot;]._state
                if e._state is &quot;hidden&quot; and (sourceState is &quot;active&quot; and targetState is &quot;active&quot;)
                    e.toggleHidden()
                else if e._state is &quot;active&quot; and (sourceState is &quot;hidden&quot; or targetState is &quot;hidden&quot;)
                    e.toggleHidden()

        # Convenience methods
        outDegree: () -&gt; @_adjacentEdges.length

        remove: -&gt;
            _.each @._adjacentEdges, (adjacentEdge) -&gt;
                adjacentEdge.remove()
            delete @a._nodes[@.id]
            @a.vis.select(&quot;#node-&quot; + @.id).remove()

Alchemy::themes = 
    &quot;default&quot;:
        &quot;backgroundColour&quot;: &quot;#000000&quot;
        &quot;nodeStyle&quot;:
            &quot;all&quot;:
                &quot;radius&quot;: -&gt; 10
                &quot;color&quot;  : -&gt; &quot;#68B9FE&quot;
                &quot;borderColor&quot;: -&gt;&quot;#127DC1&quot;
                &quot;borderWidth&quot;: (d, radius) -&gt; radius / 3
                &quot;captionColor&quot;: -&gt; &quot;#FFFFFF&quot;
                &quot;captionBackground&quot;: -&gt; null
                &quot;captionSize&quot;: 12
                &quot;selected&quot;:
                    &quot;color&quot; : -&gt; &quot;#FFFFFF&quot;
                    &quot;borderColor&quot;: -&gt; &quot;#349FE3&quot;
                &quot;highlighted&quot;:
                    &quot;color&quot; : -&gt; &quot;#EEEEFF&quot;
                &quot;hidden&quot;:
                    &quot;color&quot;: -&gt; &quot;none&quot; 
                    &quot;borderColor&quot;: -&gt; &quot;none&quot;
        &quot;edgeStyle&quot;:
            &quot;all&quot;:
                &quot;width&quot;: 4
                &quot;color&quot;: &quot;#CCC&quot;
                &quot;opacity&quot;: 0.2
                &quot;directed&quot;: true
                &quot;curved&quot;: true
                &quot;selected&quot;:
                    &quot;opacity&quot;: 1
                &quot;highlighted&quot;:
                    &quot;opacity&quot;: 1
                &quot;hidden&quot;:
                    &quot;opacity&quot;: 0

    &quot;white&quot;:
        &quot;theme&quot;: &quot;white&quot;
        &quot;backgroundColour&quot;: &quot;#FFFFFF&quot;
        &quot;nodeStyle&quot;:
            &quot;all&quot;:
                &quot;radius&quot;: -&gt; 10
                &quot;color&quot;  : -&gt; &quot;#68B9FE&quot;
                &quot;borderColor&quot;: -&gt;&quot;#127DC1&quot;
                &quot;borderWidth&quot;: (d, radius) -&gt; radius / 3
                &quot;captionColor&quot;: -&gt; &quot;#FFFFFF&quot;
                &quot;captionBackground&quot;: -&gt; null
                &quot;captionSize&quot;: 12
                &quot;selected&quot;:
                    &quot;color&quot;: -&gt; &quot;#FFFFFF&quot;
                    &quot;borderColor&quot;: -&gt; &quot;38DD38&quot;
                &quot;highlighted&quot;:
                    &quot;color&quot; : -&gt; &quot;#EEEEFF&quot;
                &quot;hidden&quot;:
                    &quot;color&quot;: -&gt; &quot;none&quot; 
                    &quot;borderColor&quot;: -&gt; &quot;none&quot;
        &quot;edgeStyle&quot;:
            &quot;all&quot;:
                &quot;width&quot;: 4
                &quot;color&quot;: &quot;#333&quot;
                &quot;opacity&quot;: 0.4
                &quot;directed&quot;: false
                &quot;curved&quot;: false
                &quot;selected&quot;:
                    &quot;color&quot;: &quot;#38DD38&quot;
                    &quot;opacity&quot;: 0.9
                &quot;highlighted&quot;:
                    &quot;color&quot;: &quot;#383838&quot;
                    &quot;opacity&quot;: 0.7
                &quot;hidden&quot;:
                    &quot;opacity&quot;: 0


Alchemy::exports = (instance)-&gt;
    a = instance
    init: ()-&gt;
        a.exports.show()

    show: ()-&gt;
        a.dash.select &quot;#all-exports&quot;
         .append &quot;li&quot;
         .attr
            class: &quot;list-group-item active-label toggle&quot;
         .html &quot;SVG&quot;
         .on &quot;click&quot;, (e)-&gt;
            svg = d3.select &quot;#{a.conf.divSelector} svg&quot;
                    .node()
            str = (new XMLSerializer).serializeToString svg
            url = &quot;data:image/svg+xml;utf8,#{str}&quot;
            sanitizedUrl = url.replace(&quot;xlink:&quot;, &quot;&quot;)
            win = window.open sanitizedUrl
            win.focus()
class warnings
    constructor: (instance) -&gt;
        @a = instance

    dataWarning: =&gt;
        if @a.conf.dataWarning and typeof @a.conf.dataWarning is &#39;function&#39;
            @a.conf.dataWarning()
        else if @a.conf.dataWarning is &#39;default&#39;
            no_results = &quot;&quot;&quot;
                        &lt;div class=&quot;modal fade&quot; id=&quot;no-results&quot;&gt;
                            &lt;div class=&quot;modal-dialog&quot;&gt;
                                &lt;div class=&quot;modal-content&quot;&gt;
                                    &lt;div class=&quot;modal-header&quot;&gt;
                                        &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt;
                                        &lt;h4 class=&quot;modal-title&quot;&gt;Sorry!&lt;/h4&gt;
                                    &lt;/div&gt;
                                    &lt;div class=&quot;modal-body&quot;&gt;
                                        &lt;p&gt;#{@a.conf.warningMessage}&lt;/p&gt;
                                    &lt;/div&gt;
                                    &lt;div class=&quot;modal-footer&quot;&gt;
                                        &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt;
                                    &lt;/div&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                       &quot;&quot;&quot;
            $(&#39;body&#39;).append no_results
            $(&#39;#no-results&#39;).modal &#39;show&#39;

    divWarning: -&gt;
        &quot;&quot;&quot;
            create an element that matches the value for &#39;divSelector&#39; in your conf.
            For instance, if you are using the default &#39;divSelector&#39; conf, simply provide
            &lt;div id=&#39;#alchemy&#39;&gt;&lt;/div&gt;.
        &quot;&quot;&quot;</code></pre>  