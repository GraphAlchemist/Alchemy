<!-- For the next release
---
position: 8
title: Anotated Source
---
-->

    """
    Alchemy.js is a graph drawing application for the web.
    Copyright (C) 2014  GraphAlchemist, Inc.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    lets
    """

    class Alchemy
        constructor: (userConf=null) ->
            @a = @

            @version  = "#VERSION#"
            @get      = new @get @
            @remove   = new @remove @
            @create   = new @create @
            @drawing  =
                DrawEdge : DrawEdge   @
                DrawEdges: DrawEdges  @
                DrawNode : DrawNode   @
                DrawNodes: DrawNodes  @
                EdgeUtils: @EdgeUtils @
                NodeUtils: @NodeUtils @

            @layout     = Layout
            @clustering = Clustering

            @models =
                Node: @Node @
                Edge: @Edge @

            @utils        = warnings: warnings
            @filters      = @filters @
            @visControls  = {}
            @styles       = {}
            @editor       = {}
            @log          = {}

            @currentRelationshipTypes = {}
            @state =
                "interactions": "default"
                "layout": "default"

            @startGraph     = @startGraph @
            @generateLayout = @generateLayout @
            @svgStyles      = @svgStyles @
            @interactions   = @interactions @
            @search         = @search @
            # alchemy._nodes stores a node object as the value with the unique
            # id specified in the GraphJSON.
            @_nodes = {}

            # alchemy._edges stores an array of edges under every unique id.
            # the edge model is a key value pair where the "key" is either
            # 1) an id provided in the GraphJSON data, or 2) an id generated by
            # Alchemy taking the format of "#{source}-#{target}".
            # The value is an array of edge 'packets', where the length of the array
            # is typically 1.
            @_edges = {}

            @begin userConf if userConf

        begin: (userConf) ->
            # overide configuration with user inputs
            @setConf userConf
            switch typeof @conf.dataSource
                when 'string' then d3.json @a.conf.dataSource, @a.startGraph
                when 'object' then @a.startGraph @a.conf.dataSource

            Alchemy::instances.push @

            @

        setConf: (userConf) ->
            # apply base themes
            if userConf.theme?
                userConf = _.merge _.cloneDeep(defaults), @a.themes["#{userConf.theme}"]

            for key, val of userConf
                switch key
                    when "clusterColors"   then userConf["clusterColours"]   = val
                    when "backgroundColor" then userConf["backgroundColour"] = val
                    when "nodeColor"       then userConf[nodeColour]         = val

            @a.conf = _.merge _.cloneDeep(defaults), userConf

        # All alchemy instances in order of creation.
        instances: []

    root = exports ? this
    root.Alchemy = Alchemy

    # Get the instance of alchemy that an element belongs to
    root._getAlchInst = (element)->
        #Edge or Node
        if element.a?
            element.a

        #_d3 packet
        else if element.self?
            element.self.a

        #SVG element
        else
            Alchemy::instances[d3.select(element).attr("alchInst")]

    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    class Alchemy::create
        constructor: (instance)->
            @a = instance
        nodes: (nodeMap, nodeMaps...) ->
            a = this.a
            registerNode = (node) ->
                # check if the node already exists
                if not a._nodes[node.id]
                    aNode = new a.models.Node(node)
                    a._nodes[node.id] = aNode
                    [aNode]
                else
                    # if the node already exists, suggest that the user uses a 
                    # different method for creating/updating the node
                    console.warn("""
                                A node with the id #{node.id} already exists.
                                Consider using the @a.get.nodes() method to 
                                retrieve the node and then using the Node methods.
                                """)

            nodeMaps = _.union nodeMaps, nodeMap
            # create the results set
            results = []
            for n in nodeMaps
                # check if the node already exists
                registerNode n
            results
        edges: (edgeMap, edgeMaps...) ->
            a = this.a
            registerEdge = (edge) ->
                # data provided a unique id and that edge does not yet exist
                if edge.id and not a._edges[edge.id]
                    aEdge = new a.models.Edge(edge)
                    a._edges[edge.id] = [aEdge]
                    [aEdge]
                # data provided a unique id and that edge already exists
                else if edge.id and a._edges[edge.id]
                    console.warn """
                        An edge with that id #{someEdgeMap.id} already exists.
                        Consider using the @a.get.edge() method to 
                        retrieve the edge and then using the Edge methods.
                        Note: id's are not required for edges.  Alchemy will create
                        an unlimited number of edges for the same source and target node.
                        Simply omit 'id' when creating the edge.
                        """
                # data did not provide a unique id and so @a uses source-target
                else
                    edgeArray = a._edges["#{edge.source}-#{edge.target}"]
                    if edgeArray
                        # edges already exist with this source target, append a new edge object
                        aEdge = new a.models.Edge(edge, edgeArray.length)
                        edgeArray.push aEdge
                        [aEdge]
                    else
                        # edge array does not exist - create the array and give the edge
                        # an id of 'source-target-0' for the first position in the array
                        aEdge = new a.models.Edge(edge, 0)
                        a._edges["#{edge.source}-#{edge.target}"] = [aEdge]
                        [aEdge]
                        
            if edgeMaps.length isnt 0
                console.warn "Make sure this function supports multiple arguments"
            else
                registerEdge edgeMap

    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.


    # make js array method called ._state
    # @a.set.  nest set inside of get

    Alchemy::get = (instance)->
        a: instance
        _el: []

        _makeChain: (inp)->
            returnedGet = @
            returnedGet.__proto__ = [].__proto__
            returnedGet.pop() while returnedGet.length
            _.each inp, (e)-> returnedGet.push(e)
            returnedGet

        # returns one or more nodes as an array
        nodes: (id, ids...) ->
                    if id?
                        allIDs = _.map arguments, (arg) -> String(arg)
                        a = @.a
                        nodeList = do (a) ->
                            if id is "all-nodes"
                                _.map a._nodes, (n) -> n
                            else
                                # All passed ids with artificially enforced type safety
                                _.filter a._nodes, (val, key)->
                                    val if _.contains allIDs, key

                    @_el = nodeList
                    @_makeChain nodeList

        # returns one or more edges as an array
        edges: (id, ids...) ->
            if id?
                allIDs = _.map arguments, (arg) -> String(arg)
                a = @.a
                edgeList = do (a) ->
                    if id is "all-edges"
                        _.flatten _.map a._edges, (n) -> n
                    else
                        # All passed ids with artificially enforced type safety
                        _.flatten _.filter a._edges, (val, key)->
                            val if _.contains allIDs, key

            @_el = edgeList
            @_makeChain edgeList

        elState: (state) ->
            elList = _.filter @_el, (e)-> e._state is state
            @_el = elList
            @_makeChain elList

        state: (key) -> if @a.state.key? then @a.state.key

        type: (type) ->
            elList = _.filter @_el, (e) -> e._nodeType is type or e._edgeType is type
            @_el = elList
            @_makeChain elList

        allNodes: (type) ->
            if type?
                _.filter @a._nodes, (n) -> n if n._nodeType is type
            else
                _.map @a._nodes, (n) -> n

        activeNodes: () ->
            _.filter @a._nodes, (node) -> node if node._state is "active"

        clusters: ->
            clusterMap = @a.layout._clustering.clusterMap
            nodesByCluster = {}
            _.each clusterMap, (key, value) ->
                nodesByCluster[value] = _.select @a.get.allNodes(), (node) ->
                    node.getProperties()[@a.conf.clusterKey] is value
            nodesByCluster

        clusterColours: ->
            clusterMap = @a.layout._clustering.clusterMap
            clusterColoursObject = {}
            _.each clusterMap, (key, value) ->
               clusterColoursObject[value] = @a.conf.clusterColours[key % @a.conf.clusterColours.length]
            clusterColoursObject

    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    class Alchemy::remove
        constructor: (instance)->
            @a = instance

        nodes: (nodeMap) ->
            _.each nodeMap, (n) ->
                if n._nodeType?
                    _.each n._adjacentEdges, (adjacentEdge) ->
                        [source, target, pos] = adjacentEdge.split("-")
                        _.remove n.a._nodes[target]._adjacentEdges, (targetAdjacentEdge) ->
                            [tSource, tTarget, tPos] = targetAdjacentEdge.split("-")
                            if tTarget is n.id.toString() or tSource  is n.id.toString()
                                targetAdjacentEdge
                        delete n.a._edges[source + "-" + target]
                        n.a.vis.select("#edge-" + source + "-" + target + "-" + pos).remove()
                    delete n.a._nodes[n.id]
                    n.a.vis.select("#node-" + n.id).remove()
        edges: (edgeMap) ->
            _.each edgeMap, (e) ->
                if e._edgeType?
                    _.remove e.a._nodes[e._properties.source]._adjacentEdges, (adjacentEdge) ->
                        [source, target, pos] = adjacentEdge.split("-")
                        if target is e._properties.target.toString()
                            adjacentEdge
                    _.remove e.a._nodes[e._properties.target]._adjacentEdges, (adjacentEdge) ->
                        [source, target, pos] = adjacentEdge.split("-")
                        if source is e._properties.source.toString()
                            adjacentEdge
                    delete e.a._edges[e.id]
                    e.a.vis.select("#edge-" + e.id + "-" + e._index).remove()

    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Alchemy::set =
        state: (key, value) -> alchemy.state.key = value

    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    class Clustering
        constructor: (instance)->
            @a = instance
            nodes = @a._nodes
            conf = @a.conf
            clustering = @

            @clusterKey = conf.clusterKey
            @identifyClusters @a
        
            _charge = -500
            _linkStrength = (edge) ->
                sourceCluster = nodes[edge.source.id]._properties[@clusterKey]
                targetCluster = nodes[edge.target.id]._properties[@clusterKey]
                if sourceCluster is targetCluster
                    0.15
                else
                    0
            _friction = () ->
                0.7
            _linkDistancefn = (edge) ->
                nodes = edge.self.a._nodes
                if nodes[edge.source.id]._properties.root or nodes[edge.target.id]._properties.root
                    300
                else if nodes[edge.source.id]._properties[@clusterKey] is nodes[edge.target.id]._properties[@clusterKey]
                    10
                else
                    600
            _gravity = (k) -> 8 * k

            @layout =
                charge: _charge
                linkStrength: (edge) -> _linkStrength(edge)
                friction: () -> _friction()
                linkDistancefn: (edge) -> _linkDistancefn(edge)
                gravity: (k) -> _gravity(k)

        identifyClusters: (a)->
            nodes = a.get.allNodes()
            clusters = _.uniq _.map(_.values(nodes), (node)-> node.getProperties()[a.conf.clusterKey])
            @clusterMap = _.zipObject clusters, [0..clusters.length]
        
        getClusterColour: (clusterValue) ->
            # Modulo reuses colors if not enough are supplied
            index = @clusterMap[clusterValue] % @a.conf.clusterColours.length
            @a.conf.clusterColours[index]

        edgeGradient: (edges) ->
            defs = @a.vis.select "#{@a.conf.divSelector} svg"
            Q = {}
            nodes = @a._nodes
            for edge in _.map(edges, (edge) -> edge._d3)
                # skip root
                continue if nodes[edge.source.id]._properties.root or nodes[edge.target.id]._properties.root
                # skip nodes from the same cluster
                continue if nodes[edge.source.id]._properties[@clusterKey] is nodes[edge.target.id]._properties[@clusterKey]
                if nodes[edge.target.id]._properties[@clusterKey] isnt nodes[edge.source.id]._properties[@clusterKey]
                    # gradient `id`
                    id = nodes[edge.source.id]._properties[@clusterKey] + "-" + nodes[edge.target.id]._properties[@clusterKey]
                    if id of Q
                        continue
                    else if id not of Q
                        startColour = @getClusterColour(nodes[edge.target.id]._properties[@clusterKey])
                        endColour = @getClusterColour(nodes[edge.source.id]._properties[@clusterKey])
                        Q[id] = {'startColour': startColour,'endColour': endColour}
            for ids of Q
                gradient_id = "cluster-gradient-" + ids
                gradient = defs.append("svg:linearGradient").attr("id", gradient_id)
                gradient.append("svg:stop").attr("offset", "0%").attr "stop-color", Q[ids]['startColour']
                gradient.append("svg:stop").attr("offset", "100%").attr "stop-color", Q[ids]['endColour']
        
    Alchemy::clusterControls =
        init: ()->
            changeClusterHTML = """
                                <input class='form-control form-inline' id='cluster-key' placeholder="Cluster Key"></input>
                                """
            @a.dash
                   .select "#clustering-container"
                   .append "div"
                   .attr "id", "cluster-key-container"
                   .attr 'class', 'property form-inline form-group'
                   .html changeClusterHTML
                   .style "display", "none"
                
            @a.dash
                   .select "#cluster_control_header"
                   .on "click", ()->
                        element = @a.dash.select "#cluster-key-container"
                        display = element.style "display"

                element.style "display", (e)-> if display is "block" then "none" else "block"

                if @a.dash.select("#cluster-key-container").style("display") is "none"
                    @a.dash
                           .select "#cluster-arrow"
                           .attr "class", "fa fa-2x fa-caret-right"
                else 
                    @a.dash
                           .select "#cluster-arrow"
                           .attr "class", "fa fa-2x fa-caret-down"
            
            @a.dash
                .select "#cluster-key"
                .on "keydown", -> 
                    if d3.event.keyIdentifier is "Enter"
                        @a.conf.cluster = true
                        @a.conf.clusterKey = this.value
                        @a.generateLayout()

    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    alchemy.controlDash = 
        init: ->
            if @dashIsShown()
                divSelector = alchemy.conf.divSelector
                # add dashboard wrapper
                alchemy.dash = d3.select "#{divSelector}"
                                 .append "div"
                                 .attr "id", "control-dash-wrapper"
                                 .attr "class", "col-md-4 initial"

                # add the dash toggle button 
                alchemy.dash
                       .append "i"
                       .attr "id", "dash-toggle"
                       .attr "class", "fa fa-flask col-md-offset-12"

                # add the control dash
                alchemy.dash
                       .append "div"
                       .attr "id", "control-dash"
                       .attr "class", "col-md-12"

                alchemy.dash.select '#dash-toggle'
                       .on 'click', alchemy.interactions.toggleControlDash

                alchemy.controlDash.zoomCtrl()
                alchemy.controlDash.search()
                alchemy.controlDash.filters()
                alchemy.controlDash.stats()
                alchemy.controlDash.clustering()

        search: ->
            if alchemy.conf.search
                alchemy.dash
                       .select "#control-dash"
                       .append "div"
                       .attr "id", "search"
                       .html """
                            <div class='input-group'>
                                <input class='form-control' placeholder='Search'>
                                <i class='input-group-addon search-icon'><span class='fa fa-search fa-1x'></span></i>
                            </div> 
                              """
                alchemy.search.init()
        
        zoomCtrl: ->
            if alchemy.conf.zoomControls 
                alchemy.dash
                    .select "#control-dash-wrapper"
                    .append "div"
                    .attr "id", "zoom-controls"
                    .attr "class", "col-md-offset-12"
                    .html "<button id='zoom-reset'  class='btn btn-defualt btn-primary'><i class='fa fa-crosshairs fa-lg'></i></button>
                            <button id='zoom-in'  class='btn btn-defualt btn-primary'><i class='fa fa-plus'></i></button>
                            <button id='zoom-out' class='btn btn-default btn-primary'><i class='fa fa-minus'></i></button>"
                
                alchemy.dash
                       .select '#zoom-in'
                       .on "click", -> alchemy.interactions.clickZoom 'in'
                
                alchemy.dash
                       .select '#zoom-out'
                       .on "click", -> alchemy.interactions.clickZoom 'out'
                
                alchemy.dash
                       .select '#zoom-reset'
                       .on "click", -> alchemy.interactions.clickZoom 'reset'

        filters: ->
            if alchemy.conf.nodeFilters or alchemy.conf.edgeFilters
                alchemy.dash
                    .select "#control-dash"
                    .append "div"
                    .attr "id", "filters"
                alchemy.filters.init()

        stats: ->
            if alchemy.conf.nodeStats or alchemy.conf.edgeStats
                stats_html = """
                        <div id = "stats-header" data-toggle="collapse" data-target="#stats #all-stats">
                        <h3>
                            Statistics
                        </h3>
                        <span class = "fa fa-caret-right fa-2x"></span>
                        </div>
                        <div id="all-stats" class="collapse">
                            <ul class = "list-group" id="node-stats"></ul>
                            <ul class = "list-group" id="rel-stats"></ul>  
                        </div>
                    """

                alchemy.dash
                    .select "#control-dash"
                    .append "div"
                    .attr "id", "stats"
                    .html stats_html
                    .select '#stats-header'
                    .on 'click', () ->
                        if alchemy.dash.select('#all-stats').classed "in"
                            alchemy.dash
                                   .select "#stats-header>span"
                                   .attr "class", "fa fa-2x fa-caret-right"
                        else
                            alchemy.dash
                                   .select "#stats-header>span"
                                   .attr "class", "fa fa-2x fa-caret-down"

                alchemy.stats.init()

        clustering: ->
            if alchemy.conf.clusterControl
                clusterControl_html = """
                        <div id="clustering-container">
                            <div id="cluster_control_header" data-toggle="collapse" data-target="#clustering #cluster-options">
                                 <h3>Clustering</h3>
                                <span id="cluster-arrow" class="fa fa-2x fa-caret-right"></span>
                            </div>
                        </div>
                        """
                alchemy.dash
                    .select "#control-dash"
                    .append "div"
                    .attr "id", "clustering"
                    .html clusterControl_html
                    .select '#cluster_control_header'

                alchemy.clusterControls.init()

        dashIsShown: ->
            conf = alchemy.conf

            conf.showEditor    || conf.captionToggle  || conf.toggleRootNodes ||
            conf.removeElement || conf.clusterControl || conf.nodeStats       ||
            conf.edgeStats     || conf.edgeFilters    || conf.nodeFilters     || 
            conf.edgesToggle   || conf.nodesToggle    || conf.search
    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.
    Alchemy::filters = (instance)=>
        a = instance
        init: () ->
            @a.filters.show()

            if @a.conf.edgeFilters then @a.filters.showEdgeFilters()
            if @a.conf.nodeFilters then @a.filters.showNodeFilters()
            #generate filter forms
            if @a.conf.nodeTypes
                nodeKey = Object.keys @a.conf.nodeTypes

                nodeTypes = ''
                for nodeType in @a.conf.nodeTypes[nodeKey]
                    # Create Filter list element
                    caption = nodeType.replace '_', ' '
                    nodeTypes += "<li class='list-group-item nodeType' role='menuitem' id='li-#{nodeType}' name=#{nodeType}>#{caption}</li>"
                @a.dash.select '#node-dropdown'
                       .html nodeTypes

            if @a.conf.edgeTypes
                for e in @a.dash.selectAll(".edge")[0]
                    @a.currentRelationshipTypes[[e].caption] = true

                edgeTypes = ''
                for edgeType in @a.conf.edgeTypes
                    # Create Filter list element
                    caption = edgeType.replace '_', ' '
                    edgeTypes += "<li class='list-group-item edgeType' role='menuitem' id='li-#{edgeType}' name=#{edgeType}>#{caption}</li>"
                @a.dash.select '#rel-dropdown'
                       .html edgeTypes

            if @a.conf.captionsToggle then @a.filters.captionsToggle()
            if @a.conf.edgesToggle then @a.filters.edgesToggle()
            if @a.conf.nodesToggle then @a.filters.nodesToggle()
            @a.filters.update()

        show: ->
            filter_html = """
                        <div id = "filter-header" data-toggle="collapse" data-target="#filters form">
                            <h3>Filters</h3>
                            <span class = "fa fa-2x fa-caret-right"></span>
                        </div>
                            <form class="form-inline collapse">
                            </form>
                          """
            @a.dash.select('#control-dash #filters').html filter_html
            @a.dash.selectAll '#filter-header'
                .on 'click', () ->
                    if @a.dash.select('#filters>form').classed "in"
                        @a.dash.select "#filter-header>span"
                               .attr "class", "fa fa-2x fa-caret-right"
                    else
                        @a.dash.select "#filter-header>span"
                               .attr "class", "fa fa-2x fa-caret-down"

            @a.dash.select '#filters form'
                   # .submit false

        #create relationship filters
        showEdgeFilters: () ->
            rel_filter_html = """
                            <div id="filter-rel-header" data-target = "#rel-dropdown" data-toggle="collapse">
                                <h4>
                                    Edge Types
                                </h4>
                                <span class="fa fa-lg fa-caret-right"></span>
                            </div>
                            <ul id="rel-dropdown" class="collapse list-group" role="menu">
                            </ul>
                               """
            @a.dash.select '#filters form'
                   .append "div"
                   .attr "id", "filter-relationships"
                   .html rel_filter_html
            @a.dash.select "#filter-rel-header"
                .on 'click', () ->
                    if @a.dash.select('#rel-dropdown').classed "in"
                        @a.dash.select "#filter-rel-header>span"
                               .attr "class", "fa fa-lg fa-caret-right"
                    else
                        @a.dash.select "#filter-rel-header>span"
                               .attr "class", "fa fa-lg fa-caret-down"

        #create node filters
        showNodeFilters: () ->
            node_filter_html = """
                                <div id="filter-node-header" data-target = "#node-dropdown" data-toggle="collapse">
                                    <h4>
                                        Node Types
                                    </h4>
                                    <span class="fa fa-lg fa-caret-right"></span>
                                </div>
                                <ul id="node-dropdown" class="collapse list-group" role="menu">
                                </ul>
                               """
            @a.dash.select '#filters form'
                   .append "div"
                   .attr "id", "filter-nodes"
                   .html node_filter_html
            @a.dash.select "#filter-node-header"
                .on 'click', () ->
                    if @a.dash.select('#node-dropdown').classed "in"
                        @a.dash.select "#filter-node-header>span"
                               .attr "class", "fa fa-lg fa-caret-right"
                    else
                        @a.dash.select "#filter-node-header>span"
                               .attr "class", "fa fa-lg fa-caret-down"

        #create captions toggle
        captionsToggle: () ->
            @a.dash.select "#filters form"
              .append "li"
              .attr {"id":"toggle-captions","class":"list-group-item active-label toggle"}
              .html "Show Captions"
              .on "click", ->
                isDisplayed = @a.dash.select("g text").attr("style")

                if isDisplayed is "display: block" || null
                    @a.dash.selectAll "g text"
                           .attr "style", "display: none"
                else
                    @a.dash.selectAll "g text"
                           .attr "style", "display: block"

        #create edges toggle
        edgesToggle: () ->
            @a.dash.select "#filters form"
              .append "li"
              .attr {"id":"toggle-edges","class":"list-group-item active-label toggle"}
              .html "Toggle Edges"
              .on "click", ->
                  if _.contains(_.pluck(_.flatten(_.values(@a._edges)), "_state"), "active")
                    _.each _.values(@a._edges), (edges)->
                        _.each edges, (e)-> if e._state is "active" then e.toggleHidden()
                  else
                    _.each _.values(@a._edges), (edges)->
                        _.each edges, (e)->
                            source = @a._nodes[e._properties.source]
                            target = @a._nodes[e._properties.target]
                            if source._state is "active" and target._state is "active"
                              e.toggleHidden()

        #create nodes toggle
        nodesToggle: () ->
            @a.dash.select "#filters form"
              .append "li"
              .attr {"id":"toggle-nodes","class":"list-group-item active-label toggle"}
              .html "Toggle Nodes"
              .on "click", ->
                  if _.contains(_.pluck(_.values(@a._nodes), "_state"), "active")
                    _.each _.values(@a._nodes), (n)->
                        if @a.conf.toggleRootNodes and n._d3.root then return
                        if n._state is "active" then n.toggleHidden()
                  else
                    _.each _.values(@a._nodes), (n)->
                        if @a.conf.toggleRootNodes and n._d3.root then return
                        n.toggleHidden()

        #update filters
        update: () ->
            @a.dash.selectAll ".nodeType, .edgeType"
                .on "click", () ->
                    element = d3.select this
                    tag = element.attr "name"
                    @a.vis.selectAll ".#{tag}"
                        .each (d)->
                            if @a._nodes[d.id]?
                                node = @a._nodes[d.id]
                                node.toggleHidden()
                            else
                                edge = @a._edges[d.id][0]
                                source = @a._nodes[edge._properties.source]
                                target = @a._nodes[edge._properties.target]
                                if source._state is "active" and target._state is "active"
                                  edge.toggleHidden()
                    @a.stats.nodeStats()

    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Alchemy::interactions = (instance)->
        a: instance
        edgeClick: (d) ->
            a = d.self.a

            d3.event.stopPropagation()
            # a = _getAlchInst d
            edge = d.self
            if edge._state != "hidden"
                edge._state = do -> 
                    return "active" if edge._state is "selected"
                    "selected"
                edge.setStyles()
            if typeof a.conf.edgeClick? is 'function'
                a.conf.edgeClick()

        edgeMouseOver: (d) ->
            edge = d.self
            if edge._state != "hidden"
                if edge._state != "selected"
                    edge._state = "highlighted"
                edge.setStyles()

        edgeMouseOut: (d) ->
            edge = d.self
            if edge._state != "hidden"
                if edge._state != "selected"
                    edge._state = "active"
                edge.setStyles()

        nodeMouseOver: (n) ->
            node = n.self
            if node._state != "hidden"
                if node._state != "selected"
                    node._state = "highlighted"
                    node.setStyles()
                if typeof @a.conf.nodeMouseOver is 'function'
                    @a.conf.nodeMouseOver(node)
                else if typeof @a.conf.nodeMouseOver is ('number' or 'string')
                    # the user provided an integer or string to be used
                    # as a data lookup key on the node in the graph json
                    node.properties[@a.conf.nodeMouseOver]

        nodeMouseOut: (n) ->
            node = n.self
            if node._state != "hidden"
                if node._state != "selected"
                    node._state = "active"
                    node.setStyles()
                if @a.conf.nodeMouseOut? and typeof @a.conf.nodeMouseOut is 'function'
                    @a.conf.nodeMouseOut(n)

        nodeClick: (n) ->
            # Don't consider drag a click
            return if d3.event.defaultPrevented

            d3.event.stopPropagation()
            node = n.self

            if node._state != "hidden"
                node._state = do -> 
                    return "active" if node._state is "selected"
                    "selected"
                node.setStyles()
            if typeof @a.conf.nodeClick is 'function'
                @a.conf.nodeClick(n)

        zoom: (extent) ->
            if not @_zoomBehavior?
                conf = this.a.conf
                @_zoomBehavior = d3.behavior.zoom().center([conf.graphWidth()/2, conf.graphHeight()/2])
            @_zoomBehavior.scaleExtent extent
                          .on "zoom", (d)->
                            d3.select(@).select("g")
                              .attr("transform", "translate(#{ d3.event.translate })scale(#{ d3.event.scale })")
                                        
        clickZoom:  (direction) ->
                        [x, y, scale] = @a.vis
                                          .attr "transform"
                                          .match /(-*\d+\.*\d*)/g
                                          .map (a) -> parseFloat(a)

                        @a.vis
                            .attr "transform", ->
                                if direction is "in"
                                    scale += 0.2 if scale < @a.conf.scaleExtent[1]
                                    return "translate(#{x},#{y}) scale(#{ scale })"
                                else if direction is "out"
                                    scale -= 0.2 if scale > @a.conf.scaleExtent[0]
                                    return "translate(#{x},#{y}) scale(#{ scale })"
                                else if direction is "reset"
                                    return "translate(0,0) scale(1)"
                                else
                                    console.log 'error'
                        if not @._zoomBehavior?
                            @._zoomBehavior = d3.behavior.zoom()
                        @._zoomBehavior.scale(scale)
                                       .translate([x,y])

        toggleControlDash: () ->
            #toggle off-canvas class on click
            offCanvas = @a.dash.classed("off-canvas") or
                        @a.dash.classed("initial")
            @a.dash
                   .classed {
                        "off-canvas": !offCanvas,
                        "initial"   : false,
                        "on-canvas" : offCanvas
                    }

        nodeDragStarted: (d, i) ->
            d3.event.preventDefault
            d3.event.sourceEvent.stopPropagation()
            d3.select(@).classed "dragging", true
            d.fixed = true

        nodeDragged: (d, i) ->
            @a = d.self.a

            d.x  += d3.event.dx
            d.y  += d3.event.dy
            d.px += d3.event.dx
            d.py += d3.event.dy

            node = d3.select @
            node.attr "transform", "translate(#{d.x}, #{d.y})"
            edgeIDs = d.self._adjacentEdges
            for id in edgeIDs
                selection = @a.vis.select "#edge-#{id}"
                @a._drawEdges.updateEdge selection.data()[0]

        nodeDragended: (d, i) ->
            a = d.self.a
            d3.select(@).classed "dragging": false
            if !a.conf.forceLocked  #@a.configuration for forceLocked
                a.force.start() #restarts force on drag

        deselectAll: () ->
            a = _getAlchInst @

            # this function is also fired at the end of a drag, do nothing if this
            if d3.event?.defaultPrevented then return
            if a.conf.showEditor is true
                a.modifyElements.nodeEditorClear()
             
            _.each a._nodes, (n)->
                n._state = "active"
                n.setStyles()
            
            _.each a._edges, (edge)->
                _.each edge, (e)->
                    e._state = "active"
                    e.setStyles()
            
            # call user-specified deselect function if specified
            if a.conf.deselectAll and typeof(a.conf.deselectAll is 'function')
                a.conf.deselectAll()

    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    class Layout
        constructor: (instance)->
            @a = instance

            conf = @a.conf
            nodes = @a._nodes

            @k = Math.sqrt Math.log(_.size(@a._nodes)) / (conf.graphWidth() * conf.graphHeight())
            @_clustering = new @a.clustering @a
            @d3NodeInternals = _.map @a._nodes, (v,k)-> v._d3

            if conf.cluster
                @_charge = () -> @_clustering.layout.charge
                @_linkStrength = (edge) -> @_clustering.layout.linkStrength(edge)
            else
                @_charge = () -> -10 / @k
                @_linkStrength = (edge) ->
                    if nodes[edge.source.id].getProperties('root') or nodes[edge.target.id].getProperties('root')
                        1
                    else
                        0.9

            if conf.cluster
                @_linkDistancefn = (edge) -> @_clustering.layout.linkDistancefn(edge)
            else if conf.linkDistancefn is 'default'
                @_linkDistancefn = (edge) ->
                    1 / (@k * 50)
            else if typeof conf.linkDistancefn is 'number'
                @_linkDistancefn = (edge) -> conf.linkDistancefn
            else if typeof conf.linkDistancefn is 'function'
                @_linkDistancefn = (edge) -> conf.linkDistancefn(edge)

            

        gravity: () =>
            if @a.conf.cluster
                @_clustering.layout.gravity @k
            else
                50 * @k

        linkStrength: (edge) =>
            @_linkStrength edge

        friction: () -> 0.9

        collide: (node) ->
            conf = @a.conf
            r = 2 * (node.radius + node['stroke-width']) + conf.nodeOverlap
            nx1 = node.x - r
            nx2 = node.x + r
            ny1 = node.y - r
            ny2 = node.y + r
            return (quad, x1, y1, x2, y2) ->
                if quad.point and (quad.point isnt node)
                    x = node.x - Math.abs quad.point.x
                    y = node.y - quad.point.y
                    l = Math.sqrt(x * x + y * y)
                    r = r
                    if l < r
                        l = (l - r) / l * @a.conf.alpha
                        node.x -= x *= l
                        node.y -= y *= l
                        quad.point.x += x
                        quad.point.y += y
                x1 > nx2 or
                x2 < nx1 or
                y1 > ny2 or
                y2 < ny1

        tick: () =>
            if @a.conf.collisionDetectionls
                q = d3.geom.quadtree @d3NodeInternals
                for node in @d3NodeInternals
                    q.visit @collide(node)

            # @a.node
            @a.vis
                .selectAll "g.node"
                .attr "transform", (d) -> "translate(#{d.x},#{d.y})"

            edges = @a.vis.selectAll "g.edge"
            @drawEdge = @a.drawing.DrawEdge
            @drawEdge.styleText edges
            @drawEdge.styleLink edges

        positionRootNodes: () ->
            conf = @a.conf
            container =
                width: conf.graphWidth()
                height: conf.graphHeight()

            rootNodes = _.filter @a.get.allNodes(), (node) -> node.getProperties('root')
            # if there is one root node, position it in the center
            if rootNodes.length is 1
                n = rootNodes[0]
                [n._d3.x, n._d3.px] = [container.width / 2, container.width / 2]
                [n._d3.y, n._d3.py] = [container.height/ 2, container.height/ 2]
                # fix root nodes until force layout is complete
                n._d3.fixed = true
                return
            # position nodes towards center of graph
            else
                for n, i in rootNodes
                    n._d3.x = container.width / Math.sqrt(rootNodes.length * (i+1))
                    n._d3.y = container.height / 2
                    n._d3.fixed = true

        chargeDistance: () ->
            500

        linkDistancefn: (edge) ->
            @_linkDistancefn edge

        charge: () ->
            @_charge()

    Alchemy::generateLayout = (instance)->
        a = instance
        (start=false)->
            conf = a.conf

            a.layout = new Layout a
            a.force = d3.layout.force()
                .size [conf.graphWidth(), conf.graphHeight()]
                .theta 1.0
                .gravity a.layout.gravity()
                .friction a.layout.friction()

                .nodes _.map(a._nodes, (node) -> node._d3)
                .links _.flatten _.map(a._edges, (edgeArray) -> e._d3 for e in edgeArray)
                .linkDistance (link) -> a.layout.linkDistancefn link
                .linkStrength (link) -> a.layout.linkStrength link
                
                .charge a.layout.charge()
                .chargeDistance a.layout.chargeDistance()            
    # A.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Alchemy::search = (instance)-> 
        a = instance
        init: () ->
            searchBox = a.dash
                         .select "#search input"

            searchBox.on "keyup", ()->
                input = searchBox[0][0].value.toLowerCase()

                a.vis
                 .selectAll ".node"
                 .classed "inactive", false
                a.vis
                 .selectAll "text"
                 .attr "style", -> "display: inline;" if input != ""
                a.vis
                 .selectAll ".node"
                 .classed "inactive", (node) ->
                    DOMtext = d3.select @
                                 .text()

                    switch a.conf.searchMethod
                        when 'contains'
                            hidden = DOMtext.toLowerCase().indexOf(input) < 0
                        when 'begins'
                            hidden = DOMtext.toLowerCase().indexOf(input) != 0

                    if hidden
                         a.vis
                          .selectAll "[source-target*='#{node.id}']"
                          .classed "inactive", hidden
                    else
                         a.vis
                          .selectAll "[source-target*='#{node.id}']"
                          .classed "inactive", (edge)-> 
                              nodeIDs = [edge.source.id, edge.target.id]

                              sourceHidden = a.vis.select("#node-#{nodeIDs[0]}").classed "inactive"
                              targetHidden = a.vis.select("#node-#{nodeIDs[1]}").classed "inactive"

                              targetHidden or sourceHidden
                    hidden
    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Alchemy::startGraph = (instance)->
        a = instance

        (data) ->
            conf = a.conf

            if d3.select(conf.divSelector).empty()
                console.warn a.utils.warnings.divWarning()

            # see if data is ok
            if not data
                a.utils.warnings.dataWarning()

            # create nodes map and update links
            a.create.nodes data.nodes

            data.edges.forEach (e) -> a.create.edges e

            # create SVG
            a.vis = d3.select conf.divSelector
                .attr "style", "width:#{conf.graphWidth()}px; height:#{conf.graphHeight()}px; background:#{conf.backgroundColour}"
                .append "svg"
                    .attr "xmlns", "http://www.w3.org/2000/svg"
                    .attr "xlink", "http://www.w3.org/1999/xlink"
                    .attr "pointer-events", "all"
                    .attr "shape-rendering", "optimizeSpeed"
                    .attr "alchInst", (d)-> Alchemy::instances.length - 1
                    .on 'click', a.interactions.deselectAll
                    .call a.interactions.zoom(conf.scaleExtent)
                    .on "dblclick.zoom", null
                    .append 'g'
                        .attr "transform","translate(#{conf.initialTranslate}) scale(#{conf.initialScale})"
            
            # Create zoom event handlers
            a.interactions.zoom().scale conf.initialScale
            a.interactions.zoom().translate conf.initialTranslate

            a.generateLayout()
            # a.controlDash.init()

            #enter/exit nodes/edges
            d3Edges = _.flatten _.map(a._edges, (edgeArray) -> e._d3 for e in edgeArray)
            d3Nodes = _.map a._nodes, (n) -> n._d3

            # if start
            a.layout.positionRootNodes()
            a.force.start()
            while a.force.alpha() > 0.005
                a.force.tick()

            a._drawEdges = a.drawing.DrawEdges
            a._drawEdges.createEdge d3Edges
            a._drawNodes = a.drawing.DrawNodes
            a._drawNodes.createNode d3Nodes 

            initialComputationDone = true
            console.log Date() + ' completed initial computation'

            nodes = a.vis.selectAll 'g.node'
                            .attr 'transform', (id, i) -> "translate(#{id.x}, #{id.y})"

            # configuration for forceLocked
            if !conf.forceLocked
                a.force
                 .on "tick", a.layout.tick
                 .start()

            # call user-specified functions after load function if specified
            # deprecate?
            if conf.afterLoad?
                if typeof conf.afterLoad is 'function'
                    conf.afterLoad()
                else if typeof conf.afterLoad is 'string'
                    a[conf.afterLoad] = true

            if conf.cluster or conf.directedEdges
                defs = d3.select("#{a.conf.divSelector} svg").append "svg:defs"

            if conf.directedEdges
                arrowSize = conf.edgeArrowSize + (conf.edgeWidth() * 2)
                marker = defs.append "svg:marker"
                    .attr "id", "arrow"
                    .attr "viewBox", "0 -#{arrowSize * 0.4} #{arrowSize} #{arrowSize}"
                    .attr 'markerUnits', 'userSpaceOnUse'
                    .attr "markerWidth", arrowSize
                    .attr "markerHeight", arrowSize
                    .attr "orient", "auto"
                marker.append "svg:path"
                    .attr "d", "M #{arrowSize},0 L 0,#{arrowSize * 0.4} L 0,-#{arrowSize * 0.4}"
                if conf.curvedEdges
                    marker.attr "refX", arrowSize + 1
                else
                    marker.attr 'refX', 1 

            if conf.nodeStats
                a.stats.nodeStats()

            if conf.showEditor
                editor = new a.editor.Editor
                editorInteractions = new a.editor.Interactions
                d3.select "body"
                    .on 'keydown', editorInteractions.deleteSelected

                editor.startEditor()

    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    alchemy.stats = 
        init: () -> 
            alchemy.stats.update()

        nodeStats: () ->
            #general node stats
            nodeStats = ''
            nodeData = []

            allNodes = alchemy.get.allNodes().length
            activeNodes = alchemy.get.activeNodes().length
            inactiveNodes = allNodes - activeNodes

            nodeStats += "<li class = 'list-group-item gen_node_stat'>Number of nodes: <span class='badge'>#{allNodes}</span></li>"            
            nodeStats += "<li class = 'list-group-item gen_node_stat'>Number of active nodes: <span class='badge'>#{activeNodes}</span></li>"
            nodeStats += "<li class = 'list-group-item gen_node_stat'>Number of inactive nodes: <span class='badge'>#{inactiveNodes}</span></li>"

            #add stats for all node types
            if alchemy.conf.nodeTypes
                nodeKeys = Object.keys(alchemy.conf.nodeTypes)
                nodeTypes = ''
                for nodeType in alchemy.conf.nodeTypes[nodeKeys]
                    caption = nodeType.replace('_', ' ')
                    nodeNum = alchemy.vis.selectAll("g.node.#{nodeType}")[0].length
                    nodeTypes += "<li class = 'list-group-item nodeType' id='li-#{nodeType}' 
                                    name = #{caption}>Number of <strong style='text-transform: uppercase'>#{caption}</strong> nodes: <span class='badge'>#{nodeNum}</span></li>"
                    nodeData.push(["#{nodeType}", nodeNum])
                nodeStats += nodeTypes

            #add the graph
            nodeGraph = "<li id='node-stats-graph' class='list-group-item'></li>" 
            nodeStats += nodeGraph
            alchemy.dash
                   .select '#node-stats'
                   .html nodeStats
            @insertSVG "node", nodeData

        edgeStats: () ->
            #general edge stats
            edgeData = null
            edgeNum = alchemy.vis.selectAll(".edge")[0].length
            activeEdges = alchemy.vis.selectAll(".edge.active")[0].length
            inactiveEdges = alchemy.vis.selectAll(".edge.inactive")[0].length

            edgeGraph = "<li class = 'list-group-item gen_edge_stat'>Number of relationships: <span class='badge'>#{edgeNum}</span></li>
                        <li class = 'list-group-item gen_edge_stat'>Number of active relationships: <span class='badge'>#{activeEdges}</span></li>
                        <li class = 'list-group-item gen_edge_stat'>Number of inactive relationships: <span class='badge'>#{inactiveEdges}</span></li>
                        <li id='edge-stats-graph' class='list-group-item'></li>"

            #add stats for edge types
            if alchemy.conf.edgeTypes
                edgeData = []
                for e in alchemy.vis.selectAll(".edge")[0]
                    alchemy.currentRelationshipTypes[[e].caption] = true

                for edgeType in alchemy.conf.edgeTypes
                    if not edgeType then continue
                    caption = edgeType.replace('_', ' ')
                    edgeNum = alchemy.vis.selectAll(".edge.#{edgeType}")[0].length
                    edgeData.push(["#{caption}", edgeNum])

            alchemy.dash
                   .select '#rel-stats'
                   .html edgeGraph 
            alchemy.stats.insertSVG "edge", edgeData
            return edgeData

        insertSVG: (element, data) ->
            if data is null 
                alchemy.dash
                       .select "##{element}-stats-graph"
                       .html "<br><h4 class='no-data'>There are no #{element}Types listed in your conf.</h4>"
            else
                width = alchemy.conf.graphWidth() * .25
                height = 250
                radius = width / 4
                color = d3.scale.category20()

                arc = d3.svg.arc()
                    .outerRadius(radius - 10)
                    .innerRadius(radius/2)

                pie = d3.layout.pie()
                    .sort(null)
                    .value((d) -> d[1])

                svg = alchemy.dash
                             .select "##{element}-stats-graph"
                             .append "svg"
                             .append "g"
                             .style {"width": width, "height":height}
                             .attr "transform", "translate(" + width/2 + "," + height/2 + ")"

                arcs = svg.selectAll ".arc"
                    .data pie(data)
                    .enter()
                    .append "g"
                    .classed "arc", true
                    .on "mouseover", (d,i) -> 
                        alchemy.dash
                          .select "##{data[i][0]}-stat"
                          .classed "hidden", false
                    .on "mouseout", (d,i) -> 
                        alchemy.dash
                          .select "##{data[i][0]}-stat"
                          .classed "hidden", true

                arcs.append "path"
                    .attr "d", arc
                    .attr "stroke", (d, i) -> color(i)
                    .attr "stroke-width", 2
                    .attr "fill-opacity", "0.3"

                arcs.append "text"
                    .attr "transform", (d) -> "translate(" + arc.centroid(d) + ")"
                    .attr "id", (d, i)-> "#{data[i][0]}-stat"
                    .attr "dy", ".35em"
                    .classed "hidden", true
                    .text (d, i) -> data[i][0]

        update: () -> 
            if alchemy.conf.nodeStats then alchemy.stats.nodeStats()
            if alchemy.conf.edgeStats then alchemy.stats.edgeStats()
    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    defaults =

        # Renderer
        renderer: "svg"

        # Layout
        graphWidth: ->
            d3.select(@divSelector).node().parentElement.clientWidth
        graphHeight: ->
            if d3.select(@divSelector).node().parentElement.nodeName is "BODY"
                window.innerHeight
            else 
                d3.select(@divSelector).node().parentElement.clientHeight
        alpha: 0.5
        collisionDetection: true
        nodeOverlap: 25
        fixNodes: false
        fixRootNodes: false
        forceLocked: true
        linkDistancefn: 'default'
        nodePositions: null # not currently implemented

        # Editing
        showEditor: false # should change to nodeEditor and edgeEditor
        captionToggle: false
        toggleRootNodes: false
        removeElement: false

        #Clustering
        cluster: false
        clusterKey: "cluster"
        clusterColours: d3.shuffle ["#DD79FF", "#FFFC00",
                                    "#00FF30", "#5168FF",
                                    "#00C0FF", "#FF004B",
                                    "#00CDCD", "#f83f00",
                                    "#f800df", "#ff8d8f",
                                    "#ffcd00", "#184fff",
                                    "#ff7e00"]
        clusterControl: false

        #Stats
        nodeStats: false
        edgeStats: false

        # Filtering
        edgeFilters: false
        nodeFilters: false
        edgesToggle: false
        nodesToggle: false

        # Controls
        zoomControls: false

        # Nodes
        nodeCaption: 'caption'
        nodeCaptionsOnByDefault: false
        nodeStyle:
            "all":
                "radius": 10
                "color"  : "#68B9FE"
                "borderColor": "#127DC1"
                "borderWidth": (d, radius) -> radius / 3
                "captionColor": "#FFFFFF"
                "captionBackground": null
                "captionSize": 12
                "selected":
                    "color" : "#FFFFFF"
                    "borderColor": "#349FE3"
                "highlighted":
                    "color" : "#EEEEFF"
                "hidden":
                    "color": "none" 
                    "borderColor": "none"

        nodeColour: null # WILL BE DEPRECATED IN 1.0
        nodeMouseOver: 'caption'
        nodeRadius: 10 # WILL BE DEPRECATED IN 1.0
        nodeTypes: null
        rootNodes: 'root'
        rootNodeRadius: 15

        # Edges
        edgeCaption: 'caption'
        edgeCaptionsOnByDefault: false
        edgeClick: 'default'
        edgeStyle:
            "all":
                "width": 4
                "color": "#CCC"
                "opacity": 0.2
                "directed": true
                "curved": true
                "selected":
                    "opacity": 1
                "highlighted":
                    "opacity": 1
                "hidden":
                    "opacity": 0
        edgeTypes: null
        curvedEdges: false
        edgeWidth: -> 4
        edgeOverlayWidth: 20
        directedEdges: false
        edgeArrowSize: 5

        # Search
        search: false
        searchMethod: "contains"

        # Misc
        backgroundColour: "#000000"
        theme: null
        afterLoad: 'afterLoad'
        divSelector: '#alchemy'
        dataSource: null
        initialScale: 1
        initialTranslate: [0,0]
        scaleExtent: [0.5, 2.4]
        dataWarning: "default"
        warningMessage: "There be no data!  What's going on?"
    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    DrawEdge = (instance)->
        a: instance
        createLink: (edge) ->
            conf = @a.conf
            curved = conf.curvedEdges
            directed = conf.directedEdges
            interactions = @a.interactions
            utils = @a.drawing.EdgeUtils

            edge.append 'path'
                .attr 'class', 'edge-line'
                .attr 'id', (d) -> "path-#{d.id}"
            edge.filter (d) -> d.caption?
                .append 'text'
            edge.append 'path'
                .attr 'class', 'edge-handler'
                .style 'stroke-width', "#{conf.edgeOverlayWidth}"

        styleLink: (edge) ->
            a = @a
            conf = @a.conf
            directed = conf.directedEdges
            utils = @a.drawing.EdgeUtils
            edge.each (d) ->
                edgeWalk = utils.edgeWalk d
                g = d3.select(@)
                g.style utils.edgeStyle d
                
                if !conf.curvedEdges #and !directed
                    g.attr('transform', 
                       "translate(#{edgeWalk.startEdgeX}, #{edgeWalk.startEdgeY}) rotate(#{edgeWalk.edgeAngle})")

                g.select('.edge-line')
                 .attr 'd',

**This can be refactored for readability (please!)**                    
                
                if conf.curvedEdges
                        angle = utils.edgeAngle d

                        sideOfY = if Math.abs(angle) > 90 then -1 else 1
                        sideOfX = do (angle) ->
                                return 0 if angle is 0
                                return if angle < 0 then -1 else 1

                        startLine = utils.startLine(d)
                        endLine = utils.endLine(d)
                        sourceX = startLine.x
                        sourceY = startLine.y
                        targetX = endLine.x
                        targetY = endLine.y

                        dx = targetX - sourceX
                        dy = targetY - sourceY
                        
                        hyp = Math.sqrt( dx * dx + dy * dy)

                        offsetX = (dx * conf.nodeRadius + 2) / hyp
                        offsetY = (dy * conf.nodeRadius + 2) / hyp

                        arrowX = (-sideOfX * ( conf.edgeArrowSize )) + offsetX
                        arrowY = ( sideOfY * ( conf.edgeArrowSize )) + offsetY
                        "M #{startLine.x},#{startLine.y} A #{hyp}, #{hyp} #{utils.captionAngle(d)} 0, 1 #{endLine.x}, #{endLine.y}"
                        # "M #{sourceX-offsetX},#{sourceY-offsetY} A #{hyp}, #{hyp} #{utils.edgeAngle(d)} 0, 1 #{targetX - arrowX}, #{targetY - arrowY}"

                else
                    if conf.directedEdges

                        ["M #{edgeWalk.startPathX} #{edgeWalk.startPathBottomY}"
                         "L #{edgeWalk.arrowBendX} #{edgeWalk.arrowBendBottomY}"
                         "L #{edgeWalk.arrowBendX} #{edgeWalk.arrowTipBottomY}"
                         "L #{edgeWalk.arrowEndX} #{edgeWalk.arrowEndY}"
                         "L #{edgeWalk.arrowBendX} #{edgeWalk.arrowTipTopY}"
                         "L #{edgeWalk.arrowBendX} #{edgeWalk.arrowBendTopY}"
                         "L #{edgeWalk.startPathX} #{edgeWalk.startPathTopY}"
                         "Z"].join " "


                    else
                        ["M #{edgeWalk.startPathX} #{edgeWalk.startPathBottomY}"
                         "L #{edgeWalk.arrowEndX} #{edgeWalk.arrowBendBottomY}"
                         "L #{edgeWalk.arrowEndX} #{edgeWalk.arrowBendTopY}"
                         "L #{edgeWalk.startPathX} #{edgeWalk.startPathTopY}"
                         "Z"].join " "

                g.select '.edge-handler'
                    .attr 'd', (d) -> g.select('.edge-line').attr('d')

        classEdge: (edge) ->
            edge.classed 'active', true

        styleText: (edge) ->
            conf = @a.conf
            curved = conf.curvedEdges
            directed = conf.directedEdges
            utils = @a.drawing.EdgeUtils

            if curved
                edge.select 'text' 
                    .each (d) ->
                        edgeWalk = utils.edgeWalk d
                        d3.select(@).attr 'dx', (d) -> utils.middlePath(d).x
                                    .attr 'dy', (d) -> utils.middlePath(d).y + 20
                                    .attr 'transform', "rotate(#{utils.captionAngle(d)})"
                                    .text d.caption
                                    .style "display", (d)-> return "block" if conf.edgeCaptionsOnByDefault
            else
                edge.select 'text'
                    .each (d) ->
                        edgeWalk = utils.edgeWalk d
                        captionAngle = utils.captionAngle(d)
                        if captionAngle is 180
                            dx = - edgeWalk.edgeLength / 2
                        else
                            dx = edgeWalk.edgeLength / 2
                        d3.select(@).attr 'dx', "#{dx}"
                                    .attr 'dy', "#{- d['stroke-width'] * 1.1}"
                                    .attr 'transform', "rotate(#{captionAngle})"
                                    .text d.caption
                                    .style "display", (d)->
                                        return "block" if conf.edgeCaptionsOnByDefault

            # TODO: Code to start having text follow path.
            # This will eliminate the need for alot of math and extra work if we can
            # simply get the text to xlink to the path itself.  It's not currently
            # working and we need to get on with the release, but it needs to be
            # implemented.
            #
            # edge.select 'text'
            #     .each (d) ->
            #         d3.select @
            #           .text d.caption
            #           .style "display", (d)-> return "block" if conf.edgeCaptionsOnByDefault
            #           .attr "xlink:xlink:href", "#path-#{d.source.id}-#{d.target.id}"

        setInteractions: (edge) ->
            interactions = @a.interactions
            # editorEnabled = @a.get.state("interactions") is "editor"
            # if editorEnabled
            #     editorInteractions = new @a.editor.Interactions
            #     edge.select '.edge-handler'
            #         .on 'click', editorInteractions.edgeClick
            # else
            edge.select '.edge-handler'
                .on 'click', interactions.edgeClick
                .on 'mouseover', (d)-> interactions.edgeMouseOver(d)
                .on 'mouseout', (d)-> interactions.edgeMouseOut(d)

    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    DrawEdges = (instance)->
        a: instance
        createEdge: (d3Edges) ->
            drawEdge = @a.drawing.DrawEdge
            edge = @a.vis.selectAll "g.edge"
                            .data d3Edges
            edge.enter().append 'g'
                        .attr "id", (d) -> "edge-#{d.id}-#{d.pos}"
                        .attr 'class', (d)->
                            "edge #{d.edgeType}"
                        .attr 'source-target', (d) -> "#{d.source.id}-#{d.target.id}"    
            drawEdge.createLink edge
            drawEdge.classEdge edge
            drawEdge.styleLink edge
            drawEdge.styleText edge
            drawEdge.setInteractions edge
            edge.exit().remove()

            if @a.conf.directedEdges and @a.conf.curvedEdges
                edge.select('.edge-line')
                    .attr('marker-end', 'url(#arrow)')

        updateEdge: (d3Edge) ->
            drawEdge = @a.drawing.DrawEdge
            edge = @a.vis.select "#edge-#{d3Edge.id}-#{d3Edge.pos}"
            drawEdge.classEdge edge
            drawEdge.styleLink edge
            drawEdge.styleText edge
            drawEdge.setInteractions edge

    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    DrawNode = (instance)->
        a: instance
        styleText: (node) ->
            conf = @a.conf
            utils = @a.drawing.NodeUtils
            nodes = @a._nodes
            node.selectAll "text"
                .attr 'dy', (d) ->
                    if nodes[d.id].getProperties().root
                        conf.rootNodeRadius / 2 
                    else 
                        conf.nodeRadius * 2 - 5
                .html (d) -> utils.nodeText(d)
                .style "display", (d)->
                    return "block" if conf.nodeCaptionsOnByDefault

        createNode: (node) ->
            node.append 'circle'
                .attr 'id', (d) -> "circle-#{d.id}"
            node.append 'svg:text'
                .attr 'id', (d) -> "text-#{d.id}"

        styleNode: (node) ->
            utils = @a.drawing.NodeUtils

            node.selectAll 'circle'
                .attr 'r', (d) ->
                    if typeof d.radius is "function"
                        d.radius()
                    else
                        d.radius
                .attr 'shape-rendering', 'optimizeSpeed'
                .each (d) -> d3.select(@).style utils.nodeStyle d


        setInteractions: (node) ->
            conf = @a.conf
            coreInteractions = @a.interactions
            editorEnabled = @a.get.state("interactions") is "editor"

            # reset drag
            drag = d3.behavior.drag()
                .origin Object
                .on "dragstart", null
                .on "drag", null
                .on "dragend", null

            if editorEnabled
                editorInteractions = new @a.editor.Interactions
                node.on 'mouseup',(d)->  editorInteractions.nodeMouseUp(d)
                    .on 'mouseover', (d)-> editorInteractions.nodeMouseOver(d)
                    .on 'mouseout', (d)-> editorInteractions.nodeMouseOut(d)
                    .on 'dblclick', (d)-> coreInteractions.nodeDoubleClick(d)
                    .on 'click', (d)-> editorInteractions.nodeClick(d)

            else 
                node.on 'mouseup', null
                    .on 'mouseover', (d)-> coreInteractions.nodeMouseOver(d)
                    .on 'mouseout', (d)-> coreInteractions.nodeMouseOut(d)
                    .on 'dblclick', (d)-> coreInteractions.nodeDoubleClick(d)
                    .on 'click', (d)-> coreInteractions.nodeClick(d)

                drag = d3.behavior.drag()
                        .origin(Object)
                        .on "dragstart", coreInteractions.nodeDragStarted
                        .on "drag", coreInteractions.nodeDragged
                        .on "dragend", coreInteractions.nodeDragended

                if not conf.fixNodes
                    nonRootNodes = node.filter (d) -> d.root isnt true
                    nonRootNodes.call drag

                if not conf.fixRootNodes
                    rootNodes = node.filter (d) -> d.root is true
                    rootNodes.call drag

    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    DrawNodes = (instance)->
        a: instance
        createNode: (d3Nodes) ->
            drawNode = @a.drawing.DrawNode

            # alchemyNode is an array of one or more alchemyNode._d3 packets
            node = @a.vis.selectAll "g.node"
                     .data d3Nodes, (n) -> n.id

            node.enter().append "g"
                .attr "class", (d) ->
                    nodeType = d.self._nodeType
                    "node #{nodeType} active"
                .attr 'id', (d) -> "node-#{d.id}"
                .classed 'root', (d) -> d.root

            drawNode.createNode node
            drawNode.styleNode node
            drawNode.styleText node
            drawNode.setInteractions node
            node.exit().remove()

        updateNode: (alchemyNode) ->
            # alchemyNode is an array of one or more alchemyNode._d3 packets
            drawNode = @a.drawing.DrawNode
            node = @a.vis.select "#node-#{alchemyNode.id}"
            drawNode.styleNode node
            drawNode.styleText node
            drawNode.setInteractions node
    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Alchemy::EdgeUtils = (instance)->
        a: instance
        edgeStyle: (d) ->
            conf = @a.conf
            edge = @a._edges[d.id][d.pos]
            styles = @a.svgStyles.edge.update edge
            nodes = @a._nodes

            # edge styles based on clustering
            if @a.conf.cluster
                clustering = @a.layout._clustering
                styles.stroke = do (d) ->
                    clusterKey = conf.clusterKey
                    source = nodes[d.source.id]._properties
                    target = nodes[d.target.id]._properties
                    if source.root or target.root
                        index = if source.root then target[clusterKey] else source[clusterKey]
                        "#{clustering.getClusterColour(index)}"
                    else if source[clusterKey] is target[clusterKey]
                        index = source[clusterKey]
                        "#{clustering.getClusterColour(index)}"
                    else if source[clusterKey] isnt target[clusterKey]
                        # use gradient between the two clusters' colours
                        id = "#{source[clusterKey]}-#{target[clusterKey]}"
                        gid = "cluster-gradient-#{id}"
                        "url(##{gid})"

            styles

        triangle: (edge) ->
            width = edge.target.x - edge.source.x
            height = edge.target.y - edge.source.y

            width: width
            height: height
            hyp: Math.sqrt height * height + width * width

This is the primary function used to draw the svg paths between
two nodes for directed or undirected noncurved edges. 

        edgeWalk: (edge) ->
            arrowSize = @a.conf.edgeArrowSize
            arrowScale = 0.3
            
Build a right triangle.

            triangle = @triangle(edge)
            width  = triangle.width
            height = triangle.height
            hyp = triangle.hyp

The widht of the stroke places a large part in how the arrow lays out with larger edge widths.

            edgeWidth = edge['stroke-width']

After all of our calculations, we offset the edge by 2 pixels to account for the curve of the node.
This typically is only noticable with opaque styles.

            curveOffset = 2

We start the edge at the very *edge* of the node, taking into account distances created by the stroke-width of the node
and edge itself.  The length of startPathX is then accounted for in the edgeLength.

            startPathX = 0 + edge.source.radius + edge.source['stroke-width'] - (edgeWidth / 2) + curveOffset
            edgeLength = hyp - startPathX - curveOffset * 1.5


The absolute angle of the edge used for caption rendering and
path rendering.

            edgeAngle: Math.atan2(height, width) / Math.PI * 180

The start of the edge in absolute coordinates.  The start of the edge and end
of the edge are simply the center of the source and target nodes.

            startEdgeX: edge.source.x
            startEdgeY: edge.source.y

            #endEdgeX: edge.target.x + (width * edge.target.radius + edge.target['stroke-width']) / hyp
            #endEdgeY: edge.target.y + (height * edge.target.radius + edge.target['stroke-width']) / hyp

The middle point of the edge, where the caption will be anchored.

            midLineX: edge.source.x + width / 2
            midLineY: edge.source.x + height / 2
            endLineX: edge.source.x + width / hyp
            endLineY: edge.source.x + height / hyp
            
Here we offset the start of the path to the very edge of the node by adding the stroke-width and the radius.
Additionally, we account for the 'stroke-width' of the edge itself, and then offeset that by one pixel to account
for the curve of the node.

            startPathX: startPathX
            startPathBottomY: edgeWidth / 2
            
            arrowBendX: edgeLength - arrowSize
            arrowBendBottomY: edgeWidth / 2
            
            arrowTipBottomY: edgeWidth / 2 + (arrowSize * arrowScale)
            
            arrowEndX: edgeLength
            arrowEndY: 0
            
            arrowTipTopY: -(arrowSize * arrowScale + edgeWidth / 2)
            
            arrowBendTopY: - edgeWidth / 2

            startPathTopY: - edgeWidth / 2

            edgeLength: edgeLength

        # Temporary drop in to reimplement curved directed edges.
        # Will be replaced once the math for the better alternative is worked out.
        curvedDirectedEdgeWalk: (edge, point)->
            conf = @a.conf

            # build a right triangle
            width  = edge.target.x - edge.source.x
            height = edge.target.y - edge.source.y
            # as in hypotenuse 
            hyp = Math.sqrt(height * height + width * width)

            newpoint = if point is 'middle'
                    distance = (hyp / 2)
                    x: edge.source.x + width * distance / hyp
                    y: edge.source.y + height * distance / hyp
                else if point is 'linkStart'
                    distance = edge.source.radius+ edge.source['stroke-width']
                    x: edge.source.x + width * distance / hyp
                    y: edge.source.y + height * distance / hyp
                else if point is 'linkEnd'
                    if conf.curvedEdges
                        distance = hyp
                    else
                        distance = hyp - (edge.target.radius + edge.target['stroke-width'])
                    if conf.directedEdges
                        distance = distance - conf.edgeArrowSize
                    x: edge.source.x + width * distance / hyp
                    y: edge.source.y + height * distance / hyp
            newpoint
        middleLine: (edge) -> @curvedDirectedEdgeWalk edge, 'middle'
        startLine: (edge) -> @curvedDirectedEdgeWalk edge, 'linkStart'
        endLine: (edge) -> @curvedDirectedEdgeWalk edge, 'linkEnd'
        
        edgeLength: (edge) ->
            # build a right triangle
            width  = edge.target.x - edge.source.x
            height = edge.target.y - edge.source.y
            # as in hypotenuse 
            hyp = Math.sqrt(height * height + width * width)
        edgeAngle: (edge) ->
            width  = edge.target.x - edge.source.x
            height = edge.target.y - edge.source.y
            Math.atan2(height, width) / Math.PI * 180
        
        captionAngle: (angle) ->
            if angle < -90 or angle > 90
                180
            else
                0
        middlePath: (edge) ->
            pathNode = @a.vis
                         .select "#path-#{edge.id}"
                         .node()
            midPoint = pathNode.getPointAtLength pathNode.getTotalLength()/2
 
            x: midPoint.x
            y: midPoint.y
                
        # Temporary fill in for curved edges until math is completed for new path only edges
        middlePathCurve: (edge) ->
            pathNode = d3.select("#path-#{edge.id}").node()
            midPoint = pathNode.getPointAtLength(pathNode.getTotalLength()/2)

            x: midPoint.x
            y: midPoint.y
    Alchemy::NodeUtils = (instance)->
            a = instance
            nodeStyle: (d) ->
                conf = a.conf
                node = d.self
                if conf.cluster and (node._state isnt "hidden")
                    d.fill = do (d)->
                        clustering = a.layout._clustering
                        nodeProp = node.getProperties()
                        clusterMap = clustering.clusterMap
                        key = conf.clusterKey
                        colours = conf.clusterColours
                        # Modulo makes sure to reuse colors if it runs out
                        colourIndex = clusterMap[nodeProp[key]] % colours.length
                        colour = colours[colourIndex]
                        "#{colour}"
                d

            nodeText: (d) ->
                conf = a.conf
                nodeProps = a._nodes[d.id]._properties
                if conf.nodeCaption and typeof conf.nodeCaption is 'string'
                    if nodeProps[conf.nodeCaption]?
                        nodeProps[conf.nodeCaption]
                    else
                        ''
                else if conf.nodeCaption and typeof conf.nodeCaption is 'function'
                    caption = conf.nodeCaption(nodeProps)
                    if caption is undefined or String(caption) is 'undefined'
                        a.log["caption"] = "At least one caption returned undefined"
                        conf.caption = false
                    caption

    Alchemy::svgStyles = (instance)->
        a: instance

        node:
            a: @a
            populate: (node) ->
                conf = @a.conf
                defaultStyle = _.omit conf.nodeStyle.all, "selected", "highlighted", "hidden"
                d = node

                # if user put in hard value, turn into a function
                toFunc = (inp)->
                    return inp if typeof inp is "function"
                    return -> inp

                nodeTypeKey = _.keys(conf.nodeTypes)[0]
                nodeType = node.getProperties()[nodeTypeKey]

                if conf.nodeStyle[nodeType] is undefined
                    nodeType = "all"

                typedStyle = _.assign _.cloneDeep(defaultStyle), conf.nodeStyle[nodeType]
                style = _.assign typedStyle, conf.nodeStyle[nodeType][node._state]

                radius = toFunc style.radius
                fill = toFunc style.color
                stroke = toFunc style.borderColor
                strokeWidth = toFunc style.borderWidth

                svgStyles = {}
                svgStyles["radius"] = radius d
                svgStyles["fill"] = fill d
                svgStyles["stroke"] = stroke d
                svgStyles["stroke-width"] = strokeWidth d, radius(d)
                
                svgStyles

        edge:
            a: @a
            populate: (edge) ->
                conf = @a.conf
                defaultStyle = _.omit conf.edgeStyle.all, "selected", "highlighted", "hidden"

                # if user put in hard value, turn into a function
                toFunc = (inp)->
                    if typeof inp is "function"
                        return inp
                    return -> inp

                edgeType = edge._edgeType

                if conf.edgeStyle[edgeType] is undefined
                    edgeType = "all"

                typedStyle = _.assign _.cloneDeep(defaultStyle), conf.edgeStyle[edgeType]
                style = _.assign typedStyle, conf.edgeStyle[edgeType][edge._state]

                width = toFunc style.width
                color = toFunc style.color
                opacity = toFunc style.opacity

                svgStyles =
                    "stroke": color edge
                    "stroke-width": width edge
                    "opacity": opacity edge
                    "fill": "none"
                    # Uncomment for flower
                    # "fill": color edge

                svgStyles

            update: (edge) ->
                conf = @a.conf
                style = edge._style
                toFunc = (inp)->
                    if typeof inp is "function"
                        return inp
                    return -> inp

                width = toFunc style.width
                color = toFunc style.color
                opacity = toFunc style.opacity

                svgStyles =
                    "stroke": color edge
                    "stroke-width": width edge
                    "opacity": opacity edge
                    "fill": "none"

                svgStyles
    # Alchemy.js is a graph drawing application for the web.
    # Copyright (C) 2014  GraphAlchemist, Inc.

    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU Affero General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.

    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU Affero General Public License for more details.

    # You should have received a copy of the GNU Affero General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.

    class Editor
        constructor: ->
            @utils = new alchemy.editor.Utils

        # init: =>
        #     if alchemy.conf.showEditor is true
        #         @showOptions()
        #         @nodeEditorInit()
        #         @edgeEditorInit()
        
        editorContainerHTML:
                """
                    <div id="editor-header" data-toggle="collapse" data-target="#editor #element-options">
                        <h3>Editor</h3><span class="fa fa-2x fa-caret-right"></span>
                    </div>
                    <div id="element-options" class="collapse">
                        <ul class="list-group"> 
                            <li class="list-group-item" id="remove">Remove Selected</li> 
                            <li class="list-group-item" id="editor-interactions">Editor mode enabled, click to disable editor interactions</li>
                        </ul>
                    </div>
                    """

        elementEditorHTML: (type) -> 
                """
                    <h4>#{type} Editor</h4>
                    <form id="add-property-form">
                        <div id="add-property">
                            <input class="form-control" id="add-prop-key" placeholder="New Property Name">
                            <input class="form-control" id="add-prop-value" placeholder="New Property Value">
                        </div>
                        <input id="add-prop-submit" type="submit" value="Add Property" placeholder="add a property to this node">
                    </form>
                    <form id="properties-list">
                        <input id="update-properties" type="submit" value="Update Properties">
                    </form>
                """

        startEditor: =>
            divSelector = alchemy.conf.divSelector
            html = @editorContainerHTML
            editor = alchemy.dash
                            .select "#control-dash"
                            .append "div"
                            .attr "id", "editor"
                            .html html
            
            editor.select '#editor-header'
                    .on 'click', () ->
                        if alchemy.dash.select('#element-options').classed "in"
                            alchemy.dash
                                   .select "#editor-header>span"
                                   .attr "class", "fa fa-2x fa-caret-right"
                        else
                            alchemy.dash
                                   .select "#editor-header>span"
                                   .attr "class", "fa fa-2x fa-caret-down"   

            editor_interactions = editor.select '#element-options ul #editor-interactions'
                .on 'click', ->
                    d3.select @
                      .attr "class", () ->
                        if alchemy.get.state() is 'editor'
                            alchemy.set.state 'interactions', 'default'
                            "inactive list-group-item"
                        else
                            alchemy.set.state 'interactions', 'editor'
                            "active list-group-item"
                      .html ->
                          if alchemy.get.state() is 'editor'
                              """Disable Editor Interactions"""
                          else 
                              """Enable Editor Interactions"""

            editor.select "#element-options ul #remove"
                  .on "click", -> alchemy.editor.remove()

            utils = @utils
            
            editor_interactions.on "click", () -> 
                    if !alchemy.dash.select("#editor-interactions").classed "active"
                        utils.enableEditor()
                        alchemy.dash.select "#editor-interactions"
                            .classed {"active": true, "inactive": false}
                            .html """Editor mode enabled, click to disable editor interactions"""
                    else 
                        utils.disableEditor()
                        alchemy.dash
                            .select "#editor-interactions"
                            .classed {"active": false, "inactive": true}
                            .html """Editor mode disabled, click to enable editor interactions"""

        # nodeEditorInit: () ->
        #     addPropHTML = """
        #                     <div id="add-property">
        #                         <input class='form-control' id='node-add-prop-key' placeholder="Property Name"></input>
        #                         <input class='form-control' id='node-add-prop-value' placeholder="Property Value"></input>
        #                     </div>
        #                 """
        #     d3.select("#element-options")
        #         .append("div")
        #         .attr("id", "node-editor")
        #         .attr("class", () ->
        #             if d3.select("#editor-interactions").classed("active")
        #                 return "enabled"
        #             else return "hidden"
        #         )
        #         .html("""<h4>Node Editor</h4>""")

        #     # node editor form and add property form
        #     d3.select("#node-editor")
        #         .append("form")
        #         .attr("id", "node-add-property")
        #         .html(addPropHTML)

        #     d3.select("#node-add-property")
        #         .append("input")
        #         .attr("id", "node-add-prop-submit")
        #         .attr("type", "submit")
        #         .attr("value", "Add Property")

        #     # submission handler
        #     d3.select("#node-add-property")
        #         .on "submit" , ->
        #             event.preventDefault()
        #             if d3.select(".node.selected").empty()
        #                 d3.selectAll("#node-add-prop-value, #node-add-prop-key")
        #                     .attr("placeholder", "select a node first")
                                
        nodeEditor: (n) =>
            divSelector = alchemy.conf.divSelector        
            editor = alchemy.dash.select "#control-dash #editor"
            options = editor.select '#element-options'
            # options.html(html)
            html = @elementEditorHTML "Node"
            elementEditor = options.append 'div'
                                    .attr 'id', 'node-editor'
                                    .html html

            elementEditor.attr "class", () ->
                        active = alchemy.dash
                                        .select "#editor-interactions"
                                        .classed "active"
                        return "enabled" if active
                        "hidden"
            
            add_property = editor.select "#node-editor form #add-property"
            add_property.select "#node-add-prop-key"
                        .attr "placeholder", "New Property Name"
                        .attr "value", null
            add_property.select "#node-add-prop-value"
                        .attr "placeholder", "New Property Value"
                        .attr "value", null

            alchemy.dash
                .select "#add-property-form"
                .on "submit", ->
                    event.preventDefault()
                    key = alchemy.dash
                                 .select '#add-prop-key'
                                 .property 'value'
                    key = key.replace /\s/g, "_"
                    value = alchemy.dash
                                   .select '#add-prop-value'
                                   .property 'value'
                    updateProperty key, value, true
                    alchemy.dash
                           .selectAll "#add-property .edited-property"
                           .classed "edited-property":false
                    @reset()

            nodeProperties = alchemy._nodes[n.id].getProperties()
            alchemy.vis
                   .select "#node-#{n.id}"
                   .classed "editing":true

            property_list = editor.select "#node-editor #properties-list"

            for property, val of nodeProperties
                node_property = property_list.append "div"
                                             .attr "id", "node-#{property}"
                                             .attr "class", "property form-inline form-group"
                
                node_property.append "label"
                                .attr "for", "node-#{property}-input"
                                .attr "class","form-control property-name"
                                .text "#{property}"
                
                node_property.append "input"
                                .attr "id", "node-#{property}-input"
                                .attr "class", "form-control property-value"
                                .attr "value", "#{val}"

            alchemy.dash
                   .select "#properties-list"
                   .on "submit", -> 
                       event.preventDefault()
                       properties = alchemy.dash.selectAll ".edited-property"
                       for property in properties[0]
                           selection = alchemy.dash.select property
                           key = selection.select("label").text()
                           value = selection.select("input").attr 'value'
                           updateProperty key, value, false
                       alchemy.dash
                              .selectAll "#node-properties-list .edited-property"
                              .classed "edited-property":false
                       @.reset()

            d3.selectAll "#add-prop-key, #add-prop-value, .property"
                .on "keydown", ->
                    if d3.event.keyCode is 13
                        event.preventDefault()
                    d3.select(@).classed {"edited-property":true}

            updateProperty = (key, value, newProperty) ->
                nodeID = n.id
                if (key!="") and (value != "")
                    alchemy._nodes[nodeID].setProperty "#{key}", "#{value}"
                    drawNodes = alchemy._drawNodes
                    drawNodes.updateNode alchemy.viz.select("#node-#{nodeID}")
                    if newProperty is true 
                        alchemy.dash
                               .select "#node-add-prop-key"
                               .attr "value", "property added/updated to key: #{key}"
                        alchemy.dash
                               .select "#node-add-prop-value"
                               .attr "value", "property at #{key} updated to: #{value}"
                    else
                        alchemy.dash
                               .select "#node-#{key}-input"
                               .attr "value", "property at #{key} updated to: #{value}"

                else
                    if newProperty is true 
                        alchemy.dash
                               .select "#node-add-prop-key"
                               .attr "value", "null or invalid input"
                        alchemy.dash
                               .select "#node-add-prop-value"
                               .attr "value", "null or invlid input"
                    else
                        alchemy.dash
                               .select "#node-#{key}-input"
                               .attr "value", "null or invalid input"
                
        editorClear: () ->
            alchemy.dash
                   .selectAll ".node"
                   .classed "editing":false
            alchemy.dash
                   .selectAll ".edge"
                   .classed "editing":false
            alchemy.dash
                   .select "#node-editor"
                   .remove()
            alchemy.dash
                   .select "#edge-editor"
                   .remove()
            alchemy.dash
                   .select "#node-add-prop-submit"
                   .attr "placeholder", ()->
                       if alchemy.vis.selectAll(".selected").empty()
                           return "select a node or edge to edit properties"
                       return "add a property to this element"

        edgeEditor: (e) ->
            divSelector = alchemy.conf.divSelector        
            editor = alchemy.dash "#control-dash #editor"
            options = editor.select '#element-options'
            html = @elementEditorHTML "Edge"
            elementEditor = options.append 'div'
                                    .attr 'id', 'edge-editor'
                                    .html html

            elementEditor.attr "class", () ->
                        return "enabled" if alchemy.dash
                                                   .select "#editor-interactions"
                                                   .classed "active"
                        "hidden"
            
            add_property = editor.select "#edge-editor form #add-property"
            add_property.select "#add-prop-key"
                        .attr "placeholder", "New Property Name"
                        .attr "value", null
            add_property.select "#add-prop-value"
                        .attr "placeholder", "New Property Value"
                        .attr "value", null
            
            edgeProperties = alchemy._edges[e.id].getProperties()
            alchemy.vis
                   .select "#edge-#{e.id}"
                   .classed "editing":true

            property_list = editor.select "#edge-editor #properties-list"

            for property, val of edgeProperties
                edge_property = property_list.append "div"
                                                .attr "id", "edge-#{property}"
                                                .attr "class", "property form-inline form-group"
                
                edge_property.append "label"
                                .attr "for", "edge-#{property}-input"
                                .attr "class","form-control property-name"
                                .text "#{property}"
                
                edge_property.append "input"
                                .attr "id", "edge-#{property}-input"
                                .attr "class", "form-control property-value"
                                .attr "value", "#{val}"

            alchemy.dash
                   .selectAll "#add-prop-key, #add-prop-value, .property"
                   .on "keydown", ->
                       if d3.event.keyCode is 13
                           event.preventDefault()
                       d3.select(@).classed {"edited-property":true}

            alchemy.dash
                .select "#add-property-form"
                .on "submit", ->
                    event.preventDefault()
                    key = alchemy.dash
                                 .select "#add-prop-key"
                                 .property 'value'
                    key = key.replace /\s/g, "_"
                    value = alchemy.dash
                                   .select "#add-prop-value"
                                   .property 'value'
                    updateProperty key, value, true

                    alchemy.dash
                           .selectAll "#add-property .edited-property"
                           .classed "edited-property":false
                    @reset()

            d3.select "#properties-list"
                .on "submit", -> 
                    event.preventDefault()
                    properties = alchemy.dash.selectAll ".edited-property"
                    for property in properties[0]
                        selection = alchemy.dash.select property
                        key = selection.select("label").text()
                        value = selection.select("input").property 'value'
                        updateProperty key, value, false

                    alchemy.dash
                           .selectAll "#properties-list .edited-property"
                           .classed "edited-property":false
                    @reset()

            updateProperty = (key, value, newProperty) ->
                edgeID = e.id
                if (key!="") and (value != "")
                    alchemy._edges[edgeID].setProperty "#{key}", "#{value}"
                    edgeSelection = alchemy.vis.select "#edge-#{edgeID}"
                    drawEdges = new alchemy.drawing.DrawEdges
                    drawEdges.updateEdge alchemy.vis.select("#edge-#{edgeID}")
                    if newProperty is true 
                        alchemy.dash
                               .select "#add-prop-key"
                               .attr "value", "property added/updated to key: #{key}"
                        alchemy.dash
                               .select "#add-prop-value"
                               .attr "value", "property at #{key} updated to: #{value}"
                    else
                        alchemy.dash
                               .select "#edge-#{key}-input"
                               .attr "value", "property at #{key} updated to: #{value}"

                else
                    if newProperty is true 
                        alchemy.dash
                               .select "#add-prop-key"
                               .attr "value", "null or invalid input"
                        alchemy.dash
                               .select "#add-prop-value"
                               .attr "value", "null or invlid input"
                    else
                        alchemy.dash
                               .select "#edge-#{key}-input"
                               .attr "value", "null or invalid input"
    class EditorInteractions
        # @mouseUpNode = null
        # @sourceNode = null
        # @targetNode = null
        # @newEdge = null
        # @click = null
        constructor: ->
            @editor = new alchemy.editor.Editor

        nodeMouseOver: (n) ->
            if !d3.select(@).select("circle").empty()
                radius = d3.select @
                           .select "circle"
                           .attr "r"
                d3.select @
                  .select "circle"
                    .attr "r", radius*3
            @

        nodeMouseUp: (n) =>
            if @sourceNode != n
                @mouseUpNode = true
                @targetNode = n
                @click = false
            else 
                @click = true
            @

        nodeMouseOut: (n) ->
            if !d3.select(@).select("circle").empty()
                radius = d3.select @
                           .select "circle"
                           .attr "r"
                d3.select @
                  .select "circle"
                  .attr "r", radius/3
            @

        nodeClick: (c) =>
            d3.event.stopPropagation()
            # select the correct nodes
            if !alchemy.vis.select("#node-#{c.id}").empty()
                selected = alchemy.vis
                                  .select "#node-#{c.id}"
                                  .classed 'selected'
                alchemy.vis
                       .select "#node-#{c.id}"
                       .classed 'selected', !selected
            @editor.editorClear()
            @editor.nodeEditor c

        edgeClick: (e) =>
            d3.event.stopPropagation()
            @editor.editorClear()
            @editor.edgeEditor e
            
        addNodeStart: (d, i) =>
            d3.event.sourceEvent.stopPropagation()
            @sourceNode = d
            alchemy.vis
                .select '#dragline'
                .classed "hidden":false
            @

        addNodeDragging: (d, i) =>
            # rework
            x2coord = d3.event.x
            y2coord = d3.event.y
            alchemy.vis
                .select '#dragline'
                .attr "x1", @sourceNode.x
                .attr "y1", @sourceNode.y
                .attr "x2", x2coord
                .attr "y2", y2coord
                .attr "style", "stroke: #FFF"
            @


        addNodeDragended: (d, i) =>
            #we moused up on an existing (different) node
            if !@click 
                if !@mouseUpNode
                    dragline = alchemy.vis.select "#dragline"
                    targetX = dragline.attr "x2"
                    targetY = dragline.attr "y2"

                    @targetNode =
                        id: "#{_.uniqueId('addedNode_')}",
                        x: parseFloat(targetX),
                        y: parseFloat(targetY),
                        caption: "node added"

                @newEdge =
                    id: "#{@sourceNode.id}-#{@targetNode.id}", 
                    source: @sourceNode.id, 
                    target: @targetNode.id, 
                    caption: "edited"

                alchemy.editor.update @targetNode, @newEdge
            
            @reset()
            @

        deleteSelected: (d) =>
            switch d3.event.keyCode
                when 8, 46
                    if !(d3.select(d3.event.target).node().tagName is ("INPUT" or "TEXTAREA"))
                        d3.event.preventDefault()
                        alchemy.editor.remove()

        reset: =>
            # reset interaciton variables
            @mouseUpNode = null
            @sourceNode = null
            @targetNode = null
            @newEdge = null
            @click = null

            #reset dragline
            alchemy.vis
                .select "#dragline"
                .classed "hidden":true
                .attr "x1", 0            
                .attr "y1", 0
                .attr "x2", 0
                .attr "y2", 0 
            @

        @

    class EditorUtils
        constructor: () ->
            @drawNodes = alchemy._drawNodes
            @drawEdges = alchemy._drawEdges

        enableEditor: () =>
            alchemy.set.state "interactions", "editor"
            dragLine = alchemy.vis
                .append "line"
                .attr "id", "dragline"

            @drawNodes.updateNode alchemy.node
            @drawEdges.updateEdge alchemy.edge
            selectedElements = alchemy.vis.selectAll ".selected"
            editor = new alchemy.editor.Editor
            if (not selectedElements.empty()) and (selectedElements.length is 1)
                if selectedElements.classed 'node'
                    editor.nodeEditor selectedElements.datum()
                    alchemy.dash
                        .select "#node-editor" 
                        .attr "class", "enabled"
                        .style "opacity", 1
                else if selectedElements.classed 'edge'
                    editor.edgeEditor selectedElements.datum()
                    alchemy.dash
                        .select "#edge-editor"
                        .attr "class", "enabled"
                        .style "opacity", 1
            else
                selectedElements.classed "selected":false

        disableEditor: () ->
            alchemy.setState "interactions", "default"
            alchemy.vis
                   .select "#dragline"
                   .remove()

            alchemy.dash
                   .select "#node-editor"
                   .transition()
                   .duration 300
                   .style "opacity", 0
            alchemy.dash
                   .select "#node-editor"
                   .transition()
                   .delay 300
                   .attr "class", "hidden"

            @drawNodes.updateNode alchemy.node
            alchemy.vis
                   .selectAll ".node"
                   .classed "selected":false

        remove: () ->
            selectedNodes = alchemy.vis.selectAll ".selected.node"
            for node in selectedNodes[0]
                nodeID = alchemy.vis
                                .select node
                                .data()[0]
                                .id

                node_data = alchemy._nodes[nodeID]
                if node_data?  
                    for edge in node_data.adjacentEdges
                        alchemy._edges = _.omit alchemy._edges, "#{edge}"
                        alchemy.edge = alchemy.edge.data _.map(alchemy._edges, (e) -> e._d3), (e)->e.id
                        alchemy.vis
                               .select "#edge-#{edge}"
                               .remove()
                    alchemy._nodes = _.omit alchemy._nodes, "#{nodeID}"
                    alchemy.node = alchemy.node.data _.map(alchemy._nodes, (n) -> n._d3), (n)->n.id
                    alchemy.vis
                           .select node
                           .remove()
                    if alchemy.get.state("interactions") is "editor"
                        alchemy.modifyElements.nodeEditorClear()

        addNode: (node) ->
            newNode = alchemy._nodes[node.id] = new alchemy.models.Node {id:"#{node.id}"}
            newNode.setProperty "caption", node.caption
            newNode.setD3Property "x", node.x
            newNode.setD3Property "y", node.y
            alchemy.node = alchemy.node.data _.map(alchemy._nodes, (n) -> n._d3), (n)->n.id

        addEdge: (edge) ->
            newEdge = alchemy._edges[edge.id] = new alchemy.models.Edge edge
            alchemy.edge = alchemy.edge.data _.map(alchemy._edges, (e) -> e._d3), (e)->e.id

        update: (node, edge) ->
            #only push the node if it didn't previously exist
            if !@mouseUpNode
                alchemy.editor.addNode node
                alchemy.editor.addEdge edge
                @drawEdges.createEdge alchemy.edge
                @drawNodes.createNode alchemy.node

            else
                alchemy.editor.addEdge edge
                @drawEdges.createEdge alchemy.edge

            alchemy.layout.tick()

    Alchemy::Edge = (instance)->
        class Edge
            # takes an edge property map from GraphJSON
            # as well as an index, which is the position of the edge map in
            # the array of edges stored in @a._edges at each "source-target"
            # this is used to create the id for the individual node which will be "source-target-index"
            # e.g. 1-0-1
            constructor: (edge, index=null) ->
                @a = instance
                conf = @a.conf

                @id = @_setID edge
                @_index = index
                @_state = "active"
                @_properties = edge
                @_edgeType = @_setEdgeType()
                @_style =
                    if conf.edgeStyle[@_edgeType]?
                        _.merge _.clone(conf.edgeStyle["all"]), conf.edgeStyle[@_edgeType]
                    else
                        _.clone conf.edgeStyle["all"]
                @_d3 = _.merge
                    'id': @id
                    'pos': @_index
                    'edgeType': @_edgeType
                    'source': @a._nodes[@_properties.source]._d3
                    'target': @a._nodes[@_properties.target]._d3
                    'self': @
                    , @a.svgStyles.edge.populate @
                @_setCaption(edge, conf)
                # Add id to source/target's edgelist
                @a._nodes["#{edge.source}"]._addEdge "#{@id}-#{@_index}"
                @a._nodes["#{edge.target}"]._addEdge "#{@id}-#{@_index}"

            _setD3Properties: (props) => _.merge @_d3, props

            _setID: (e) => if e.id? then e.id else "#{e.source}-#{e.target}"

            _setCaption: (edge, conf) =>
                cap = conf.edgeCaption
                edgeCaption = do (edge) ->
                    switch typeof cap
                        when ('string' or 'number') then edge[cap]
                        when 'function' then cap(edge)
                if edgeCaption
                    @_d3.caption = edgeCaption

            _setEdgeType: ->
                conf = @a.conf
                if conf.edgeTypes
                    if _.isPlainObject conf.edgeTypes
                        lookup = Object.keys @a.conf.edgeTypes
                        edgeType = @_properties[lookup]
                    else if _.isArray conf.edgeTypes
                        edgeType = @_properties["caption"]
                    else if typeof conf.edgeTypes is 'string'
                        edgeType = @_properties[conf.edgeTypes]
                if edgeType is undefined then edgeType = "all"
                @_setD3Properties 'edgeType', edgeType
                edgeType

            getProperties: (key=null, keys...) =>
                if not key? and (keys.length is 0)
                    @_properties
                else if keys.length isnt 0
                    query = _.union [key], keys
                    _.pick @_properties, query
                else
                    @_properties[key]

            setProperties: (property, value=null) =>
                if _.isPlainObject property
                    _.assign @_properties, property
                    if 'source' of property then @_setD3Properties {'source': alchemy._nodes[property.source]._d3}
                    if 'target' of property then @_setD3Properties {'target': alchemy._nodes[property.target]._d3}
                else
                    @_properties[property] = value
                    if (property is 'source') or (property is 'target')
                        @_setD3Properties {property: alchemy._nodes[value]._d3}
                @

            getStyles: (key=null, keys...) =>
                if not key? and (keys.length is 0)
                    @_style
                else if keys.length isnt 0
                    query = _.union [key], keys
                    _.pick @_style, query
                else
                    @_style[key]

            setStyles: (key, value=null) ->
                # If undefined, set styles based on state
                if key is undefined
                    key = @a.svgStyles.edge.populate @

                # takes a key, value or map of key values
                # the user passes a map of styles to set multiple styles at once
                if _.isPlainObject key
                    _.assign @_style, key
                else if typeof key is "string"
                    @_style[key] = value

                @_setD3Properties @a.svgStyles.edge.update(@)
                @a._drawEdges.updateEdge @_d3
                @

            toggleHidden: ()->
                @._state = if @._state is "hidden" then "active" else "hidden"
                @.setStyles()

            allNodesActive: () =>
                sourceId = @_properties.source
                targetId = @_properties.target
                sourceNode = alchemy.get.nodes(sourceId)[0]
                targetNode = alchemy.get.nodes(targetId)[0]
                sourceNode._state is "active" and targetNode._state is "active"

    Alchemy::Node = (instance)->
        class Node
            constructor: (node) ->
                @a = instance
                conf = @a.conf

                @id = node.id
                @_properties = node
                @_d3 = _.merge
                    'id': @id
                    'root': @_properties[conf.rootNodes]
                    'self': @
                    , @a.svgStyles.node.populate @
                @_nodeType = @_setNodeType()
                @_style =
                    if conf.nodeStyle[@_nodeType]
                        conf.nodeStyle[@_nodeType]
                    else
                        conf.nodeStyle["all"]
                @_state = "active"

                @_adjacentEdges = []

            # internal methods
            _setNodeType: =>
                conf = @a.conf
                if conf.nodeTypes
                    if _.isPlainObject conf.nodeTypes
                        lookup = Object.keys @a.conf.nodeTypes
                        types = _.values conf.nodeTypes
                        nodeType = @_properties[lookup]
                    else if typeof conf.nodeTypes is 'string'
                        nodeType = @_properties[conf.nodeTypes]
                if nodeType is undefined then nodeType = "all"
                @_setD3Properties 'nodeType', nodeType
                nodeType

            _setD3Properties: (props) =>
                _.merge @_d3, props

            _addEdge: (edgeDomID) ->
                # Stores edge.id for easy edge lookup
                @_adjacentEdges = _.union @_adjacentEdges, [edgeDomID]

            # Edit node properties
            getProperties: (key=null, keys...) =>
                if not key? and (keys.length is 0)
                    @_properties
                else if keys.length isnt 0
                    query = _.union [key], keys
                    _.pick @_properties, query
                else
                    @_properties[key]

            setProperty: (property, value=null) =>
                if _.isPlainObject property
                    _.assign @_properties, property
                else
                    @_properties[property] = value
                @

            removeProperty: (property) ->
                delete @_properties[property]
                @


            # Style methods
            getStyles: (key=null) =>
                if key?
                    @_style[key]
                else
                    @_style

            setStyles: (key, value=null) ->
                # If undefined, set styles based on state
                if key is undefined
                    key = @a.svgStyles.node.populate @
                # takes a key, value or map of key values
                # the user passes a map of styles to set multiple styles at once
                else if _.isPlainObject key
                    _.assign @_style, key
                else
                    @_style[key] = value
                @_setD3Properties @a.svgStyles.node.populate @
                @a._drawNodes.updateNode @_d3
                @

            toggleHidden: ->
                a = @a
                @_state = if @_state is "hidden" then "active" else "hidden"
                @setStyles()
                _.each @_adjacentEdges, (id)->
                    [source, target, pos] = id.split("-")
                    e = a._edges["#{source}-#{target}"][pos]
                    sourceState = a._nodes["#{source}"]._state
                    targetState = a._nodes["#{target}"]._state
                    if e._state is "hidden" and (sourceState is "active" and targetState is "active")
                      e.toggleHidden()
                    else if e._state is "active" and (sourceState is "hidden" or targetState is "hidden")
                      e.toggleHidden()

            # Convenience methods
            outDegree: () -> @_adjacentEdges.length
    Alchemy::themes = 
        "default":
            "backgroundColour": "#000000"
            "nodeStyle":
                "all":
                    "radius": -> 10
                    "color"  : -> "#68B9FE"
                    "borderColor": ->"#127DC1"
                    "borderWidth": (d, radius) -> radius / 3
                    "captionColor": -> "#FFFFFF"
                    "captionBackground": -> null
                    "captionSize": 12
                    "selected":
                        "color" : -> "#FFFFFF"
                        "borderColor": -> "#349FE3"
                    "highlighted":
                        "color" : -> "#EEEEFF"
                    "hidden":
                        "color": -> "none" 
                        "borderColor": -> "none"
            "edgeStyle":
                "all":
                    "width": 4
                    "color": "#CCC"
                    "opacity": 0.2
                    "directed": true
                    "curved": true
                    "selected":
                        "opacity": 1
                    "highlighted":
                        "opacity": 1
                    "hidden":
                        "opacity": 0

        "white":
            "theme": "white"
            "backgroundColour": "#FFFFFF"
            "nodeStyle":
                "all":
                    "radius": -> 10
                    "color"  : -> "#68B9FE"
                    "borderColor": ->"#127DC1"
                    "borderWidth": (d, radius) -> radius / 3
                    "captionColor": -> "#FFFFFF"
                    "captionBackground": -> null
                    "captionSize": 12
                    "selected":
                        "color": -> "#FFFFFF"
                        "borderColor": -> "38DD38"
                    "highlighted":
                        "color" : -> "#EEEEFF"
                    "hidden":
                        "color": -> "none" 
                        "borderColor": -> "none"
            "edgeStyle":
                "all":
                    "width": 4
                    "color": "#333"
                    "opacity": 0.4
                    "directed": false
                    "curved": false
                    "selected":
                        "color": "#38DD38"
                        "opacity": 0.9
                    "highlighted":
                        "color": "#383838"
                        "opacity": 0.7
                    "hidden":
                        "opacity": 0

    class warnings
        dataWarning: ->
            if alchemy.conf.dataWarning and typeof alchemy.conf.dataWarning is 'function'
                alchemy.conf.dataWarning()
            else if alchemy.conf.dataWarning is 'default'
                no_results = """
                            <div class="modal fade" id="no-results">
                                <div class="modal-dialog">
                                    <div class="modal-content">
                                        <div class="modal-header">
                                            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
                                            <h4 class="modal-title">Sorry!</h4>
                                        </div>
                                        <div class="modal-body">
                                            <p>#{alchemy.conf.warningMessage}</p>
                                        </div>
                                        <div class="modal-footer">
                                            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                           """
                $('body').append no_results
                $('#no-results').modal 'show'
        divWarning: ->
            """
                create an element that matches the value for 'divSelector' in your conf.
                For instance, if you are using the default 'divSelector' conf, simply provide
                <div id='#alchemy'></div>.
            """